<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="android,java,blog,code" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="￥.￥">
<meta property="og:type" content="website">
<meta property="og:title" content="Duan">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Duan">
<meta property="og:description" content="￥.￥">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Duan">
<meta name="twitter:description" content="￥.￥">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Duan</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Duan</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The more hard, the more fortunate.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/19/Kotlin-学习笔记-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="James Duan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Duan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/19/Kotlin-学习笔记-01/" itemprop="url">Kotlin 学习笔记 - 01</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-19T16:41:11+08:00">
                2017-05-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文地址：<a href="http://www.cnblogs.com/figozhg/p/4983919.html" target="_blank" rel="external">用Kotlin开发Android应用</a></p>
<h3 id="1-类定义"><a href="#1-类定义" class="headerlink" title="1 类定义"></a>1 类定义</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Personal</span></span>(</div><div class="line">        <span class="keyword">var</span> name: String,</div><div class="line">        <span class="keyword">var</span> id: <span class="built_in">Int</span> = <span class="number">1</span>,</div><div class="line">        <span class="keyword">var</span> sex: String = <span class="string">"male"</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>格式：类名(构造参数…)<br>构造参数可以指定默认值，那么在初始化实例时，对应位置参数就可以不传值，方法也是，但这里要注意顺序的问题，如 id 不想传值，sex 想传值，这种情况的话似乎不行（就目前学到的关于 Kotlin 的知识来说）<br>初始化方式有以下几种：<br><code>val per = Personal(12)</code><br><code>val per1 = Personal(13,&quot;lili&quot;)</code><br><code>val per2 = Personal(14,&quot;tom&quot;,&quot;male&quot;)</code><br>另外构造参数同时可以作为该类的属性（域），可以直接操作：<br><code>per.name = &quot;jack&quot;</code><br><code>val id = per.id</code></p>
<h3 id="2-字符串构造"><a href="#2-字符串构造" class="headerlink" title="2 字符串构造"></a>2 字符串构造</h3><p>使用 <code>${}</code> 嵌入字符串中<br><code>System.out.println(&quot;person name is = ${per.name}&quot;)</code><br>如果对变量直接引用则只需使用 <code>$</code> 后跟变量名即可<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(</span></span></div><div class="line">        <span class="keyword">var</span> sex = <span class="string">"male"</span></div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"person sex is = <span class="subst">$sex</span>"</span>)</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>注意：<br>当<code>$sex</code>紧接着就是字母、数字或下划线时仍需要使用 <code>{}</code></p>
<h3 id="3-空类型安全"><a href="#3-空类型安全" class="headerlink" title="3 空类型安全"></a>3 空类型安全</h3><h4 id="3-1-使用-显示指明对象可以为-null"><a href="#3-1-使用-显示指明对象可以为-null" class="headerlink" title="3.1 使用 ? 显示指明对象可以为 null"></a>3.1 使用 <code>?</code> 显示指明对象可以为 null</h4><p>此时要明确指定数据类型<br><code>var sex: String?</code><br>也只有这样，这个参数才能被赋为 null<br><code>var sex: String? = null</code><br>即不能为 null （没有 ? ）的变量是不允许赋 null 的，从而避免遇到非预期的空指针异常</p>
<p>当变量可以为 null ，那么使用该变量的时候 Kotlin 就强制必须判断是否为 null<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> mTextView:TextView? = <span class="literal">null</span></div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</div><div class="line">        setContentView(R.layout.activity_main)</div><div class="line">        initViews(<span class="literal">null</span>)</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initViews</span><span class="params">(view: <span class="type">View</span>?)</span></span> &#123;</div><div class="line">        mTextView = findViewById(R.id.text_view) <span class="keyword">as</span> TextView?</div><div class="line">        mTextView?.text = <span class="string">"i have change the text"</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意这一句，如果不加 <code>?</code>，编译是无法通过的。<br><code>mTextView?.text = &quot;i have change the text&quot;</code></p>
<h4 id="3-2-确定不为-null-才使用，否则抛出异常"><a href="#3-2-确定不为-null-才使用，否则抛出异常" class="headerlink" title="3.2 确定不为 null 才使用，否则抛出异常"></a>3.2 确定不为 null 才使用，否则抛出异常</h4><p><code>id!!.toString()</code><br>使用 <code>!!</code> 代表，表示使用的时候开发者断定此变量一定不会为 null 。但如果开发者错了，变量为 null，那么程序会抛运行时异常而立即终止，开发者需要承担程序终止的风险，所有没十足的把握就尽量不用吧。</p>
<h4 id="3-3-如果为空就给一个值"><a href="#3-3-如果为空就给一个值" class="headerlink" title="3.3 如果为空就给一个值"></a>3.3 如果为空就给一个值</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testNull</span><span class="params">(id: <span class="type">Int</span>? = <span class="literal">null</span>)</span></span> &#123;</div><div class="line">       <span class="keyword">val</span> caseNull = id?.toString()</div><div class="line">       <span class="keyword">val</span> tr = caseNull ?: <span class="string">"144"</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>id 不为 null 才调用 toString 方法，id 为 null 则 id.toString 也为 null，此时caseNull 也会为 null，要使 caseNull 不为 null，就使用 <code>?:</code> 为其指定一个值。<br>也可以简写为：<code>val tr = id?.toString()?: &quot;144&quot;</code></p>
<h3 id="4-扩展函数"><a href="#4-扩展函数" class="headerlink" title="4 扩展函数"></a>4 扩展函数</h3><p>可以为任何类添加新函数，只需在函数名前加上类名。在调用处，该函数将被导入到类中。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">fun</span> Activity.<span class="title">toast</span><span class="params">(context: <span class="type">Context</span>, message: <span class="type">CharSequence</span>, duration: <span class="type">Int</span> = Toast.LENGTH_SHORT)</span></span> &#123;</div><div class="line">    Toast.makeText(context, <span class="string">"msg:<span class="subst">$message</span>"</span>, duration).show()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以在 Activity 中这样使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> util = Util()</div><div class="line">    util.toast(<span class="keyword">this</span>,<span class="string">"a test msg"</span>)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但不能过度使用，应创建专门的委托类</p>
<h3 id="5-函数式支持"><a href="#5-函数式支持" class="headerlink" title="5 函数式支持"></a>5 函数式支持</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">val</span> util = Util()</div><div class="line">	<span class="keyword">val</span> tv = TextView(<span class="keyword">this</span>)</div><div class="line">	tv.setOnClickListener &#123; </div><div class="line">	    <span class="keyword">var</span> i = <span class="number">12</span></div><div class="line">	    util.toast(<span class="keyword">this</span>,<span class="string">"click <span class="subst">$i</span>"</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-when-关键字"><a href="#6-when-关键字" class="headerlink" title="6 when 关键字"></a>6 when 关键字</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</div><div class="line">     <span class="keyword">var</span> ii = <span class="number">0</span></div><div class="line">        <span class="keyword">when</span> (ii) &#123;</div><div class="line">            <span class="number">0</span> -&gt; println( <span class="string">"0：<span class="subst">$ii</span>"</span>)</div><div class="line">            <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> -&gt; println(<span class="string">"1-10：<span class="subst">$ii</span>"</span>)</div><div class="line">            <span class="keyword">else</span> -&gt; println(<span class="string">"<span class="subst">$ii</span>"</span>)</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>in：在区间内（闭区间）<br>else：否则</p>
<h3 id="7-open-关键字"><a href="#7-open-关键字" class="headerlink" title="7 open 关键字"></a>7 open 关键字</h3><p>一个类想被继承，必须标注为 open<br>一个方法想被覆写，父类方法上要加 open，子类覆写时要加 override</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</div><div class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUtil</span><span class="params">()</span></span>: Util &#123;</div><div class="line">        <span class="keyword">return</span> Util()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringUtil</span> : <span class="type">Util</span></span>() &#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUtil</span><span class="params">()</span></span>: Util &#123;</div><div class="line">        <span class="keyword">return</span> StringUtil()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="8-Data-class"><a href="#8-Data-class" class="headerlink" title="8 Data class"></a>8 Data class</h3><p>Java 中我们会创建一些只用于保存数据的实体类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</div><div class="line">        <span class="keyword">var</span> name: String,</div><div class="line">        <span class="keyword">var</span> id: <span class="built_in">Int</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>hashCode equals toString getter/setter 自动生成</p>
<h3 id="9-其他知识点"><a href="#9-其他知识点" class="headerlink" title="9 其他知识点"></a>9 其他知识点</h3><ul>
<li>语句末可以（推荐）不使用 ; 号</li>
<li>强类型语言：变量类型确定后就不能更改（不能强转）</li>
<li>var：一般类型</li>
<li>val：最终类型（只能赋值一次）</li>
<li>使用 : 代替 java 中的 extends 关键字，所继承的类型同时要调用其构造方法</li>
<li>类型和名称以另一种方式编写，用冒号分割。</li>
<li>在Java中，我们可以用注释使我们的代码更清晰，但不是必须的。而Kotlin强制我们这么做。</li>
<li>方法参数：类型和名称以另一种方式编写，用冒号分割。</li>
<li>显示使用 override </li>
</ul>
<center><u><b><em>END</em></b></u></center>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/16/Android-的消息机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="James Duan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Duan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/16/Android-的消息机制/" itemprop="url">Android 的消息机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-16T19:29:29+08:00">
                2017-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Android-Android-的消息机制"><a href="#Android-Android-的消息机制" class="headerlink" title="Android-Android 的消息机制"></a>Android-Android 的消息机制</h3><blockquote>
<p>Android 的消息机制主要指的是 Handler 的运行机制，Handler 是 Android 消息机制的上层接口，通过 Handler 可以轻松的将一个任务切换到 Handler 所在的线程中去执行，由于 Android 开发规范的限制，我们不能在非 UI 线程中更新 UI，同时不应该也不能在 UI 线程中进行耗时的 I/O 操作或者进行网络访问，这时就需要使用 Handler。</p>
</blockquote>
<h4 id="1-Handler、MessageQueue、Looper-概述"><a href="#1-Handler、MessageQueue、Looper-概述" class="headerlink" title="1 Handler、MessageQueue、Looper 概述"></a>1 Handler、MessageQueue、Looper 概述</h4><blockquote>
<p>Handler 的运行需要底层的 MessageQueue 和 Looper 的支撑。</p>
</blockquote>
<ul>
<li>MessageQueue：其中文翻译是“消息队列”，内部存储了一组消息（Message），虽然叫消息队列，但其内部使用的数据结构并不是队列，而是单链表。</li>
<li>Looper：Looper 会以无限循环的方式去 MessageQueue 中查找是否还有未处理的消息或新消息，有的话就处理，没有则等待。</li>
<li>ThreadLocal：Looper 中使用到了 ThreadLocal ，ThreadLocal 并不是线程，我们知道 Handler 创建时会采用当前线程的 Looper 来构造消息循环系统，那他怎么找到当前线程的 Looper 实例呢？ThreadLocal 可以在每个线程中存储同一个对象的不同副本，即不同线程可以调用同一个 ThreadLocal 实例的方法获取属于自己的 Looper 实例，</li>
</ul>
<h4 id="2-Android-消息机制概述"><a href="#2-Android-消息机制概述" class="headerlink" title="2 Android 消息机制概述"></a>2 Android 消息机制概述</h4><h5 id="2-1-ViewRootImpl"><a href="#2-1-ViewRootImpl" class="headerlink" title="2.1 ViewRootImpl"></a>2.1 ViewRootImpl</h5><blockquote>
<p>ViewRootImpl 是链接 WindowManager 和DecorView 的纽带，另外 View 的绘制也是通过ViewRootImpl 来完成的。</p>
</blockquote>
<p>它的主要作用总结如下：</p>
<ul>
<li>链接WindowManager和DecorView的纽带，更广一点可以说是Window和View之间的纽带。</li>
<li>完成View的绘制过程，包括measure、layout、draw过程。</li>
<li>向DecorView分发收到的用户发起的event事件，如按键，触屏等事件。</li>
</ul>
<p>ViewRootImpl 是View 树的树根，但它不是View，它实现了 View 与 WindowManager 之间的通信协议，<br>参考链接：<a href="http://www.2cto.com/kf/201606/519988.html" target="_blank" rel="external">Android中的ViewRootImpl类源码解析</a></p>
<h5 id="2-2-系统怎么知道你在哪里更新的-UI"><a href="#2-2-系统怎么知道你在哪里更新的-UI" class="headerlink" title="2.2 系统怎么知道你在哪里更新的 UI"></a>2.2 系统怎么知道你在哪里更新的 UI</h5><p>Android 规定开发着不能在非 UI 线程中更新 UI，如果你不遵守这个规定，那么将引发运行时异常<code>CalledFromWrongThreadException</code>，其原因在于 ViewRootImpl 对 UI 操作做了验证， ViewRootImpl 作为视图层次结构的顶部，对 UI 的访问操作大部分都会传递到 ViewRootImpl  中，ViewRootImpl 会在 checkThread 方法中检查访问操作是否在 UI 线程，不是的话就会抛出异常。</p>
<p></p><h5><center>ViewRootImpl # checkThread() </center><p></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</div><div class="line">                 <span class="string">"Only the original thread that created a view hierarchy can touch its views."</span>);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h5 id="2-3-系统为什么不允许在-UI-线程中访问-UI-呢？"><a href="#2-3-系统为什么不允许在-UI-线程中访问-UI-呢？" class="headerlink" title="2.3 系统为什么不允许在 UI 线程中访问 UI 呢？"></a>2.3 系统为什么不允许在 UI 线程中访问 UI 呢？</h5><blockquote>
<p>这是因为 Android 的 UI 控件不是线程安全的，如果在多线程中并发访问可能会导致 UI 控件处于不可预期的状态，那为什么不对 UI 控件的访问加上锁呢？缺点有两个：首先加上锁机制会让 UI 访问的逻辑变得复杂；其次锁机制会降低 UI 访问的效率，因为锁机制会阻塞某些线程的执行。</p>
</blockquote>
<h4 id="3-ThreadLocal-的工作原理"><a href="#3-ThreadLocal-的工作原理" class="headerlink" title="3 ThreadLocal 的工作原理"></a>3 ThreadLocal 的工作原理</h4><blockquote>
<p><u><b>java.lang.ThreadLocal</b></u></p>
<p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。 </p>
<p>ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储后，只有在指定线程中可以获取到数据，对于其他线程来说则无法获取到数据。</p>
</blockquote>
<p>举个栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    ThreadLocal&lt;Integer&gt; mLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Main test = <span class="keyword">new</span> Main ();</div><div class="line">		test.mLocal.set(<span class="number">30</span>);</div><div class="line">        test.print(<span class="string">"thread: "</span> + Thread.currentThread().getName() + <span class="string">" "</span> + test.mLocal.get());</div><div class="line">        test.test();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span> </span>&#123;</div><div class="line">        System.out.println(string);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread#1"</span>) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                mLocal.set(<span class="number">31</span>);</div><div class="line">                print(<span class="string">"thread: "</span> + <span class="keyword">this</span>.getName() + <span class="string">" "</span> + mLocal.get());</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread#2"</span>) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                mLocal.set(<span class="number">32</span>);</div><div class="line">                print(<span class="string">"thread: "</span> + <span class="keyword">this</span>.getName() + <span class="string">" "</span> + mLocal.get());</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread#3"</span>) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                mLocal.set(<span class="number">32</span>);</div><div class="line">                print(<span class="string">"thread: "</span> + <span class="keyword">this</span>.getName() + <span class="string">" "</span> + mLocal.get());</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子在执行 test 方法时，启动了三个线程，在这三个线程中分别修改了 mLocal 的值，当各自线程通过调用 ThreadLocal 的 get 方法取值时取到的值是不同的，即各个线程有属于自己的一个值。</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">F:\<span class="title">javaStuff</span>&gt;<span class="title">javac</span> <span class="title">Main.java</span></span></div><div class="line"><span class="title">F</span>:\<span class="title">javaStuff</span>&gt;<span class="title">java</span> <span class="title">Main</span></div><div class="line"><span class="title">thread</span>: <span class="title">main</span> 30</div><div class="line"><span class="title">thread</span>: <span class="title">Thread</span>#1 31</div><div class="line"><span class="title">thread</span>: <span class="title">Thread</span>#2 32</div><div class="line"><span class="title">thread</span>: <span class="title">Thread</span>#3 32</div></pre></td></tr></table></figure>
<blockquote>
<p>ThreadLocal 之所以有这么奇妙的功能，是因为不同线程访问同一个 ThreadLocal 对象的 get 方法，ThreadLocal 内部会从各自的线程中取出一个数据实体，然后再从数据实体中取得对应的 value 值。</p>
</blockquote>
<p>那这个线程私有的数据实体在哪呢？<br>先看看 ThreadLocal 的 get 方法</p>
<p></p><h5><center>JDK 1.8.0_45  ThreadLocal # get () </center><p></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> (T)e.value;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> setInitialValue();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到这里使用了 ThreadLocalMap.Entry 来保存数据，在《Android 开发艺术探索》一书中说的是使用 ThreadLocal.Values 来保存数据，这里的不同应该是由于 JDK 版本升级过程导致的。<br>再看看在 Thread 中 对 ThreadLocalMap 的引用：</p>
<p></p><h5><center>Thread # threadLocals </center><p></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></div><div class="line">     * by the ThreadLocal class. */</div><div class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
<p>从 ThreadLocal 的 get方法可以知道<code>getMap(t)</code>操作会得到当前线程的 threadLocals 对象，看看 getMap 方法。</p>
<p></p><h5><center>ThreadLocal # getMap(Thread t)</center><p></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> t.threadLocals;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>到这里就很清晰了，getMap 方法会返回当前线程的 threadLocals  。</p>
<h5 id="3-1-ThreadLocal-使用场景"><a href="#3-1-ThreadLocal-使用场景" class="headerlink" title="3.1 ThreadLocal 使用场景"></a>3.1 ThreadLocal 使用场景</h5><ul>
<li>当某些数据是以线程作为作用域并且不同线程具有不同的数据副本。</li>
<li>复杂逻辑下的数据传递，比如监听器的传递，有些时候一个线程中的任务过于复杂，这可能表现为函数调用栈比较深以及代码入口的多样性，在这种情况下我们又需要监听器贯穿整个线程的执行过程，这个时候该怎么办？这个时候就可以采用 ThreadLocal ，采用 ThreadLocal 可以让监听器作为线程内的全局对象，在线程内部只需调用 ThreadLocal 的 get 方法就能获得监听器。</li>
</ul>
<h4 id="4-MessageQueue-的工作原理"><a href="#4-MessageQueue-的工作原理" class="headerlink" title="4 MessageQueue 的工作原理"></a>4 MessageQueue 的工作原理</h4><p>一个 Handler 可以正常工作的线程只会有一个 MessageQueue 的实例。<br>MessageQueue 主要包含两个操作：</p>
<ul>
<li>插入：enqueueMessage</li>
<li>删除（读取）：next</li>
</ul>
<h5 id="4-1-enqueueMessage-方法"><a href="#4-1-enqueueMessage-方法" class="headerlink" title="4.1 enqueueMessage 方法"></a>4.1 enqueueMessage 方法</h5><p></p><h5><center>MessageQueue # enqueueMessage(Message msg, long when) </center><p></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        ...</div><div class="line">        msg.markInUse();</div><div class="line">        msg.when = when;</div><div class="line">        Message p = mMessages;</div><div class="line">        <span class="keyword">boolean</span> needWake;</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</div><div class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">            needWake = mBlocked;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ...</div><div class="line">            Message prev;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                    needWake = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></div><div class="line">            prev.next = msg;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>if (p == null || when == 0 || when &lt; p.when) {..</code>： 其中 p 为下一个待处理的消息，如果 p 为 null，或插入消息的执行时间为“立刻”(when  == 0)，或插入消息执行时间比下一个待处理消息早，那么插入消息就做为新的消息队列头，将其插入对头（<code>msg.next = p; mMessages = msg;</code>）。<br>若该判断不满足，即当前消息队列不为空，插入消息的执行时间不是“立刻”，则将其插入队列（按执行时间排序）。</p>
<h5 id="4-1-next-方法"><a href="#4-1-next-方法" class="headerlink" title="4.1 next 方法"></a>4.1 next 方法</h5><p></p><h5><center>MessageQueue # next() </center><p></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</div><div class="line">                Binder.flushPendingCommands();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class="line"></div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                <span class="comment">// Try to retrieve the next message.  Return if found.</span></div><div class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">                Message prevMsg = <span class="keyword">null</span>;</div><div class="line">                Message msg = mMessages;</div><div class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        prevMsg = msg;</div><div class="line">                        msg = msg.next;</div><div class="line">                    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (now &lt; msg.when) &#123;</div><div class="line">                        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></div><div class="line">                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// Got a message.</span></div><div class="line">                        mBlocked = <span class="keyword">false</span>;</div><div class="line">                        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</div><div class="line">                            prevMsg.next = msg.next;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            mMessages = msg.next;</div><div class="line">                        &#125;</div><div class="line">                        msg.next = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</div><div class="line">                        msg.markInUse();</div><div class="line">                        <span class="keyword">return</span> msg;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// No more messages.</span></div><div class="line">                    nextPollTimeoutMillis = -<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">		...</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>可以发现 next 方法是一个无限循环方法，如果消息队列中没有消息，那么 next 方法会一直阻塞。当有新的消息到来时，next 方法会返回这条消息并将其从单链表中移除。</p>
</blockquote>
<p>MessageQueue 的 next 方法会被 Looper 的 loop 方法调用，从而使 loop 方法也成为阻塞方法。</p>
<h4 id="4-Looper-的工作原理"><a href="#4-Looper-的工作原理" class="headerlink" title="4 Looper 的工作原理"></a>4 Looper 的工作原理</h4><p>一个 Handler 可以正常工作的线程只会有一个 Looper 的实例。</p>
<blockquote>
<p>Looper 在 Android 的消息机制中扮演者消息循环的角色，具体来说就是它会不断的从 MessageQueue 中查看是否有新消息，如果有新消息就立刻处理，否则就一直阻塞在那里。</p>
</blockquote>
<p>先看看 Looper 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">       mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</div><div class="line">       mThread = Thread.currentThread();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看到 Looper 的构造方法是私有的，即外界无法通过 new 关键字创建其实例。<br>构造方法会实例化 MessageQueue 的实例 <code>mQueue</code>。</p>
<h5 id="4-1-在非-UI-线程使用-Handler"><a href="#4-1-在非-UI-线程使用-Handler" class="headerlink" title="4.1 在非 UI 线程使用 Handler"></a>4.1 在非 UI 线程使用 Handler</h5><ul>
<li><p>如果想在一个子线程（非 UI 线程）中正常的使用 Handler ，就必须让当前线程拥有一个 Looper（Looper.prepare()），并且执行其 loop （Looper.loop()）方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Handler mHandler;</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">new</span> Thread() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">               mHandler = <span class="keyword">new</span> Handler();</div><div class="line">               Looper.prepare();</div><div class="line">               Looper.loop();</div><div class="line">           &#125;</div><div class="line">       &#125;.start();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>看看 Looper.prepare() 方法<br></p><h5><center>Looper # prepare() </center><p></p>
</h5></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">       prepare(<span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">      &#125;</div><div class="line">      sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><code>sThreadLocal.get()</code> 返回结果不为空表示当前线程的 Looper.prepare() 方法已经被调用过，即当前线程已存在 Looper 实例。这就可以保证一个线程只有一个Looper，同时也保证了一个线程只有一个 MessageQueue （参照 Looper 构造方法可知）。<br>这里有个关键的变量 <code>sThreadLocal</code>，看看它的声明：</p>
<p></p><h5><center>Looper # sThreadLocal  </center><p></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</div></pre></td></tr></table></figure>
<p>参照上面对 ThreadLocal 的说明就可以知道 <code>sThreadLocal.get()</code>返回的是当前线程对应的那个 Looper 对象。 </p>
<ul>
<li>Looper.loop() 方法</li>
</ul>
<blockquote>
<p>Looper 最重要的一个方法是 loop 方法，只有调用了 loop 后，消息循环系统才会正真的起作用。</p>
</blockquote>
<p> </p><h5><center>Looper # loop() </center><p></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">       <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">       <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">       <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">       Binder.clearCallingIdentity();</div><div class="line">       <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">       <span class="keyword">for</span> (;;) &#123;</div><div class="line">           Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">           <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></div><div class="line">           <span class="keyword">final</span> Printer logging = me.mLogging;</div><div class="line">           <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">               logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                       msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</div><div class="line">           <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</div><div class="line">               Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               msg.target.dispatchMessage(msg);</div><div class="line">           &#125; <span class="keyword">finally</span> &#123;</div><div class="line">               <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</div><div class="line">                   Trace.traceEnd(traceTag);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">               logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Make sure that during the course of dispatching the</span></div><div class="line">           <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">           <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">           <span class="keyword">if</span> (ident != newIdent) &#123;</div><div class="line">               Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></div><div class="line">                       + Long.toHexString(ident) + <span class="string">" to 0x"</span></div><div class="line">                       + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></div><div class="line">                       + msg.target.getClass().getName() + <span class="string">" "</span></div><div class="line">                       + msg.callback + <span class="string">" what="</span> + msg.what);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           msg.recycleUnchecked();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>myLooper()</code>：方法可以获得当前线程的 Looper，该方法是 public 的，在类外也可以调用。</li>
<li><code>Message msg = queue.next(); // might block</code>：next 方法在上面分析<em>MessageQueue 的工作原理</em>时已经分析过了，会next 方法是一个无限循环方法，如果消息队列中没有消息，那么 next 方法会一直阻塞。当有新的消息到来时，next 方法会返回这条消息并将其从单链表中移除。如果 next 方法返回 null，那么 loop 循环就会结束，</li>
<li><code>msg.target.dispatchMessage(msg);</code>：当 next 有消息返回时，Looper 就会处理这条消息，这里的 msg.target 时发送这条消息的 Handler 对象，这样 Handler 发送的消息最终又交给它的 dispatchMessage 方法来处理了。这里要注意的是，dispatchMessage 方法会是在创建 Handler 的线程中执行的，这样就成功的将代码逻辑切换到指定的线程中去执行。（dispatchMessage  方法将在 <u>Handler 的工作原理</u> 中分析）</li>
</ul>
<h5 id="4-2-主线程（ActivityThread-）的消息循环"><a href="#4-2-主线程（ActivityThread-）的消息循环" class="headerlink" title="4.2 主线程（ActivityThread ）的消息循环"></a>4.2 主线程（ActivityThread ）的消息循环</h5><p>Android 的主线程由 ActivityThread 类表示。</p>
<blockquote>
<p>Looper 除了 prepare 方法外，还提供了 prepareMainLooper 方法，这个方法主要是给主线程也就是 ActivityThread 创建 Looper 使用的，其本质也是通过 prepare 方法来实现的。</p>
<p>Java 程序少不了会有一个执行入口 main 方法，那 Android 程序的 main方法在哪呢？<br>其实 Android 的 main 方法被包装在 ActivityThread 类中。所有的 Android 程序都有且仅有一个ActivityThread 类的实例，ActivityThread 所在的线程即为主线程（UI 线程）。</p>
</blockquote>
<p>Android 程序 从ActivityThread 的 main 方法开始执行，调用 prepareMain 方法为主线程创建一个 Looper 和 一个 MessageQueue，然后创建一个 ActivityThread 对象，在 ActivityThread 的初始化代码中会创建一个 Handler 对象。接着 main 方法会调用 Looper.loop() 方法进入消息循环，不断地从消息队列中读取并处理消息。</p>
<p>参考链接：<br><a href="http://blog.csdn.net/lfdfhl/article/details/51279160" target="_blank" rel="external"> Android中线程那些事</a><br><a href="http://www.jianshu.com/p/0efc71f349c8" target="_blank" rel="external">ActivityThread的main方法究竟做了什么？</a></p>
<p></p><h5><center>ActivityThread  # main(String[] args)</center><p></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">     ...</div><div class="line">     Looper.prepareMainLooper();</div><div class="line"></div><div class="line">     ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">     thread.attach(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</div><div class="line">         sMainThreadHandler = thread.getHandler();</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</div><div class="line">         Looper.myLooper().setMessageLogging(<span class="keyword">new</span></div><div class="line">                 LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// End of event ActivityThreadMain.</span></div><div class="line">     Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">     Looper.loop();</div><div class="line"></div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这里就产生了一个挺有趣的问题：<u><b>ActivityThread 的 main 方法会在 loop 方法处不断循环，没有要处理的消息就会<strong>阻塞</strong>，那为什么这里的阻塞不会引发 ANR（Application Not Responding） 呢？</b></u></p>
<p>想象这样一种情况，如果不执行 loop 方法，那么 Android 程序的主线程一运行完程序就会退出！即用户才打开 APP ，APP 就自己关了，这显然是不可以的。<br>那 Android 是怎么实现阻塞而不引发 ANR 呢？</p>
<p>这里需要先了解 ANR 的产生原因：</p>
<ul>
<li>当前的事件没有机会得到处理（即主线程正在处理前一个事件，前一个事件没有及时的完成或者 looper 被某种原因阻塞住了）</li>
<li>当前的事件正在处理，但没能在规定时间内完成（广播事件处理的 10s 限定，输入事件分发 5s ，前台服务 20s 等）</li>
</ul>
<p>由 ANR 产生的原因可以知道一个关键的因素是 —— <strong>没有及时完成</strong>，即在规定时间内没有完成，而主线程 loop 循环这个操作系统并没有对其有时间限定，而 loop 循环内部在处理消息时，对某个具体消息的执行有时是有时间限定的，超过了这个时间就会引发 ANR。</p>
<h5 id="4-3-Looper-的退出方式"><a href="#4-3-Looper-的退出方式" class="headerlink" title="4.3 Looper 的退出方式"></a>4.3 Looper 的退出方式</h5><blockquote>
<p>Looper 也是可以退出的，Looper 提供了 quit 和 quitSafely 来退出一个 Looper</p>
</blockquote>
<ul>
<li>quit 和 quitSafely 方法<br>这两个方法的区别在于： quit 方法会直接退出 Looper，而 quitSafely 只是设定一个退出标记，然后把消息队列中的已有消息处理完成后才安全退出。<br><h5><center>Looper # quit() &amp; quitSafely()</center></h5></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</div><div class="line">        mQueue.quit(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</div><div class="line">        mQueue.quit(<span class="keyword">true</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到都调用了 MessageQueue 的 quit 方法。看看 MessageQueue 的 quit 方法</p>
<p></p><h5><center>MessageQueue # quit(boolean safe)</center><p></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (!mQuitAllowed) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Main thread not allowed to quit."</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">           <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125;</div><div class="line">           mQuitting = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">           <span class="keyword">if</span> (safe) &#123;</div><div class="line">               removeAllFutureMessagesLocked();</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               removeAllMessagesLocked();</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></div><div class="line">           nativeWake(mPtr);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>若当前的 MessageQueue 实例属于主线程，那么调用主线程 Looper 的 quit（或 quitSafely）都会抛出这个异常，<code>mQuitAllowed</code>变量在 Looper 的 prepareMainLooper 方法中会被赋值为 false（具体在<code>private static void prepare(boolean quitAllowed)</code>方法中赋值）。</p>
<p>参照 loop 方法可知当 MessageQueue 的 next 方法返回为 null 时，loop 循环就会退出，由此可知，<code>removeAllMessagesLocked</code>方法会直接将下一个待处理消息置为 null，这样 next 方法调用时就会返回 null；<code>removeAllFutureMessagesLocked</code>方法则会在当前消息队列的队尾添加一个 null 消息，并拒绝再接收消息，那么当当前已有的消息处理完就会返回给 next 方法 null，loop 循环就会结束。</p>
<h4 id="5-Handler-的工作原理"><a href="#5-Handler-的工作原理" class="headerlink" title="5 Handler 的工作原理"></a>5 Handler 的工作原理</h4><blockquote>
<p>Handler 的工作主要包括消息的发送和接收。消息的发送可以通过 post 的一系列方法以及 send 的一系列方法来实现，post 的一系列方法最终是通过 send 的一系列方法来实现的。</p>
</blockquote>
<p>send 一系列方法：</p>
<ul>
<li>立即发送消息一条消息：sendMessage</li>
<li>发送空的延迟消息：sendEmptyMessageDelayed</li>
<li>立即发送一条空消息：sendEmptyMessage         </li>
<li>发送一条消息到队列头：sendMessageAtFrontOfQueue </li>
<li>在指定时间发送消息：sendMessageAtTime         </li>
<li>发送延迟消息：sendMessageDelayed        </li>
<li>在指定时间发送空消息：sendEmptyMessageAtTime   </li>
</ul>
<p>post 一系列方法：发送 Runnable 对象，内部调用的是 send 的一系列方法</p>
<ul>
<li>post </li>
<li>postDelayed  </li>
<li>postAtFrontOfQueue   </li>
<li>postAtTime</li>
<li>sendMessageAtTime </li>
</ul>
<p>send 和 post 的一系列方法最终的函数调用（真正进行消息发送操作）为 <code>sendMessageAtTime</code>，或是<code>sendMessageAtFrontOfQueue</code>方法，其他的 sendXXX 和 postXXX 方法最后都会转到这两个方法，对这两个方法进行分析如下</p>
<h5 id="5-1-sendMessageAtTime-方法"><a href="#5-1-sendMessageAtTime-方法" class="headerlink" title="5.1 sendMessageAtTime 方法"></a>5.1 sendMessageAtTime 方法</h5><p>send 的一系列方法中 sendMessage、sendEmptyMessageDelayed、sendEmptyMessage、sendMessageDelayed、sendEmptyMessageAtTime 方法；post 的一系列方法 post、postDelayed、postAtTime 方法的最终调用都为 sendMessageAtTime 方法。</p>
<p></p><h5><center>Handler # sendMessageAtTime(Message msg, long uptimeMillis) </center><p></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">        MessageQueue queue = mQueue;</div><div class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>方法的第二个参数<code>uptimeMillis</code>文档中解释为：传递该消息的绝对时间，该时间将以 SystemClock.uptimeMillis（开机的到现在的毫秒数，不包括系统睡眠时间）的值作为基数。</p>
<p><code>sendMessageDelayed</code>或<code>sendMessageDelayed</code>方法内部会调用<code>sendMessageAtTime</code>方法，调用形式大都是这样的：<code>sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis)</code>,延迟时间（delayMillis）加上开机到现在的毫秒数即为发送该条消息的绝对时间，<code>sendMessage</code>方法中会调用<code>sendMessageDelayed</code>方法，此时传入的<code>delayMillis</code>就为 0 。</p>
<p>可以看到该方法内部首先会检查 mQueue 是否为 null，为 null 就表示当前线程没有 MessageQueue 对象，为什么没有 MessageQueue 对象，问问自己，MessageQueue 的实例应该在哪里实例化? 在Looper 的构造函数里，那 Looper 的构造函数又在哪里调用呢？ 在 Looper.prepare() …….，对了，很多时候程序抛出该异常就是因为你忘了调用 Looper.prepare() 方法。 </p>
<p>接下来调用 enqueueMessage 方法，看名字就可以猜出来其内部肯定会调用 MessageQueue 的 enqueueMessage 方法将消息插入到消息队列中。</p>
<p></p><h5><center>Handler # enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) </center><p></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">        msg.target = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="5-2-sendMessageAtFrontOfQueue-方法"><a href="#5-2-sendMessageAtFrontOfQueue-方法" class="headerlink" title="5.2 sendMessageAtFrontOfQueue 方法"></a>5.2 sendMessageAtFrontOfQueue 方法</h5><p>send 一系列方法的 sendMessageAtFrontOfQueue；post 一系列方法的 postAtFrontOfQueue 方法的最终调用为  sendMessageAtFrontOfQueue 方法。</p>
<p></p><h5><center>Handler # sendMessageAtFrontOfQueue(Message msg) </center><p></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtFrontOfQueue</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法同样会检查 mQueue 是否为 null。<br>注意这里调用<code>enqueueMessage</code>方法时传入的 <code>uptimeMillis</code> 的值为 0 ，你可以往上翻翻，找到 MessageQueue 的 <code>enqueueMessage(Message msg, long when)</code>方法的分析，此时传到 MessageQueue 的 enqueueMessage 方法里的     <code>when</code>的值就为 0 ，通过<code>MessageQueue#enqueueMessage</code>方法就可以知道，当 <code>when == 0</code>，该条消息将被插入消息队列的队头位置。</p>
<h5 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结"></a>5.3 总结</h5><blockquote>
<p>可以发现 Handler 发送消息的过程仅仅是向消息队列中插入一条消息，MessageQueue 的 next 方法就会返回 这条消息给 Looper，Looper 收到消息后开始处理，最终消息由 Handler 处理，即 Handler 的 dispatchMessage 方法会被调用，这时 Handler 就进入处理消息的阶段。 </p>
</blockquote>
<h5 id="5-4-Handler-的-dispatchMessage-方法"><a href="#5-4-Handler-的-dispatchMessage-方法" class="headerlink" title="5.4 Handler 的 dispatchMessage 方法"></a>5.4 Handler 的 dispatchMessage 方法</h5><blockquote>
<p>dispatchMessage 方法会检查消息（Message）的 callback 是否为 null，不为 null 就 通过 handleCallback 来处理消息，实际上就是 Handler 的一系列 post 方法传过来的 Runable 参数。</p>
</blockquote>
<p> </p><h5><center>Handler # dispatchMessage(Message msg) </center><p></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>dispatchMessage 方法先会检查消息的 callback 是否为 null，其次检查 Handler 的 mCallback 是否为 null，不为 null 则调用其 handleMessage 方法，若该方法返回 true 则消息处理完成，否则（最后）调用 Handler 对象的 handleMessage 方法处理消息。</p>
<p>这里有个小技巧，Handler 的 mCallback 域，通常我们使用 Handler 的方法是使用其导出来（子类），或者是匿名内部类（实质也是子类），这是我们就需要覆写 Handler 的 handleMessage 方法。那如果不想通过继承的方式使用 Handler 呢，mCallback 就是一种途径：<br>Handler 提供了一个构造函数<code>public Handler(Callback callback)</code>，这就允许我们通过传参的方式使用 Handler。</p>
<p>上面提到的几个变量，Message 的 callback，Handler 的 mCallback，callback 是 Runnable 对象，mCallback 为 Handler 的内部类。</p>
<p> </p><h5><center>Handler # Callback  </center><p></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<p>文章部分内容摘抄自《Android 开发艺术探索》第 10 章 —— Android 的消息机制，加上大部分自己的理解和总结，可能有错误，欢迎指正。</p>
<center><b><u><em>END</em></u><ub></ub></b></center></h5></h5></h5></h5></h5></h5></h5></h5></h5></h5></h5></h5></h5></h5></h5>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/13/Android-View-的工作原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="James Duan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Duan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/13/Android-View-的工作原理/" itemprop="url">Android：View 的工作原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-13T18:53:29+08:00">
                2017-05-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Android-View-的工作原理"><a href="#Android-View-的工作原理" class="headerlink" title="Android-View 的工作原理"></a>Android-View 的工作原理</h3><blockquote>
<p>View 的工作流程主要指的是 measure、layout、draw 这三大流程，即测量、布局和绘制，其中 measure 确定 View 的测量宽/ 高，layout 确定 View 的最终宽/高和四个顶点的位置，而 draw 则将 View 绘制到屏幕。</p>
</blockquote>
<p>在介绍 View 的三大流程之前，需要先了解 ViewRoot、DecorView 和 MeasureSpec 的基本概念，才能更好的理解 View 的 measure、layout、draw过程。<br><br></p>
<h4 id="1-ViewRoot-和-DecorView"><a href="#1-ViewRoot-和-DecorView" class="headerlink" title="1 ViewRoot 和 DecorView"></a>1 ViewRoot 和 DecorView</h4><blockquote>
<ul>
<li>ViewRoot 对应于 ViewRootImpl 类，它是连接 WindowManager 和 DecorView 的纽带，View 的三大流程均是通过 ViewRoot 来完成的。<br><br></li>
<li>View 的绘制流程是从 ViewRoot 的 performTraversals 方法开始的，它经过 measure、layout 和 draw 三个过程才能最终将一个 View 绘制出来，<br><br></li>
<li>measure 决定了 View 的宽和高，measure 完成之后，可以通过 getMeasureHeight/Width 来获得 View 的测量宽和高，在几乎所有情况下它都是与 View 的最终宽高相等的（getHeight/Width）。 layout 过程决定了 View 的四个顶点和最终宽高，完成以后就可以通过 getTop/Left/Bottom/Right 来获得其四个顶点相对父容器的坐标。只有 draw 完成以后 View 的内容才会呈现到屏幕上。<br><br></li>
<li>DecorView 做为顶级 View ，一般情况其内部会包含一个竖直方向的 LinearLayout，该 LinearLayout 分为两部分，上面部分为 标题栏，下面为内容栏。内容栏为一个 id 为 android.R.id.content 的 FrameLayout，而平时开发使用 setContentView 时就是将 View 添加到这个 FrameLayout 中。<br>因此要在 Activity 中获得我们设置的 View，可通过如下方式获得：<br><code>View contentView = 
((ViewGroup)getWindow().getDecorView().findViewbyId(android.R.Id.content)).getChildAt(0);</code></li>
</ul>
</blockquote>
<h4 id="2-MeasureSpec"><a href="#2-MeasureSpec" class="headerlink" title="2 MeasureSpec"></a>2 MeasureSpec</h4><blockquote>
<p>MeasureSpec 代表一个 32 为的 int 值，高 2 位代表 SpecMode，低 30 位表示 SpecSize，SpecMode 指测量模式，SpecSize 指某种测量模式下的规格大小。</p>
</blockquote>
<h5 id="2-1-SpecMode-有三种"><a href="#2-1-SpecMode-有三种" class="headerlink" title="2.1 SpecMode 有三种"></a>2.1 SpecMode 有三种</h5><ul>
<li>UNSPECIFIED 父容器不对 View 有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。<br><br></li>
<li>EXACTLY 父容器已经测出 View 所需的精确大小，这个时候 View 的最终大小就是 SpecSize 的值。<strong>它对应于 LayoutParams 中的 match_parent 和具体的数值这两种模式</strong>。<br><br></li>
<li>AT_MOST 父容器指定一个可用的最大大小即 SpecSize，View 的大小不能大于这个值，具体是什么要看不同 VIew 的具体实现。<strong>它对应于 LayoutParams 中的 warp_content</strong>。</li>
</ul>
<h5 id="2-2-MeasureSpec-和-LayoutParams-的对应关系"><a href="#2-2-MeasureSpec-和-LayoutParams-的对应关系" class="headerlink" title="2.2 MeasureSpec 和 LayoutParams 的对应关系"></a>2.2 MeasureSpec 和 LayoutParams 的对应关系</h5><p>MeasureSpec 的值是我们无法直接控制的，但我们可以通过给 View 设置 LayoutParams 来间接修改 MeasureSpec 的值。</p>
<blockquote>
<p>在 View 测量的时候，系统会将 LayoutParams 在父容器的约束下转换为对应的 MeasureSpec，然后根据这个 MeasureSpec 测量出 View 的宽高。需要注意的是父容器传给待测 View（子 View）的 MeasureSpec 的值由 子 View 的 LayoutParams 和父容器（父容器的 MeasureSpec）共同决定。</p>
</blockquote>
<p>子 View 的 MeasureSpec 赋值规则在<strong><code>ViewGroup#getChildMeasureSpec(int spec, int padding, int childDimension)</code></strong>方法中定义：<br>该方法的调用可在 ViewGroup 的 <code>measureChild</code>和<code>measureChildWithMargins</code>方法中找到。</p>
<p>赋值规则可总结为如下表格：<br><img src="http://img.blog.csdn.net/20170513185032164?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><br>由上表可以清晰的看出子 View 的 MeasureSpec 的确定规则，比如当父容器的 MeasureSpec 的 SpecMode 为 EXACTLY： </p>
<ul>
<li>子 View 的 LayoutParams (android:width/height)为具体数值（如20dp）时，子 View 的<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>方法中得到的 MeasureSpec（widthMeasureSpec 或 heightMeasureSpec）的 SpecMode 将为 EXACTLY，SpecSize 为 20dp；<br><br></li>
<li>子 View 的 LayoutParams (android:width/height)为 match_parent 时，子 View 的 MeasureSpec 的 SpecMode 将为 EXACTLY，SpecSize 为父容器的大小；<br><br></li>
<li>子 View 的 LayoutParams (android:width/height)为 warp_content 时，子 View 的 MeasureSpec 的 SpecMode 将为 AT_MOST，SpecSiz 为父容器的大小。<br><br></li>
<li>UNSPECIFIED 主要用于系统内部多次 Measure 的情形，一般来说，不需要关注。</li>
</ul>
<h5 id="2-3-MeasureSpec-的传递"><a href="#2-3-MeasureSpec-的传递" class="headerlink" title="2.3 MeasureSpec 的传递"></a>2.3 MeasureSpec 的传递</h5><p>父容器（ViewGroup）传递给子 View 的 MeasureSpec 的值通过<strong><code>getChildMeasureSpec</code></strong>方法确定，父容器将多次调用该方法以分别求得子 View 的<code>widthMeasureSpec</code>和<code>widthMeasureSpec</code>，然后调用子 View 的<code>measure</code>方法，最终将子 View 的 MeasureSpec 传递到<code>onMeasure</code>方法中完成子 View 的测量。</p>
<h4 id="3-measure-过程"><a href="#3-measure-过程" class="headerlink" title="3 measure 过程"></a>3 measure 过程</h4><blockquote>
<p>measure 过程分情况来看，如果只是一个原始的 View（继承体系中没有 ViewGroup），那么通过 measure 方法就完成其测量过程，如果是 ViewGroup ，除了完成自己的测量过程外，还要遍历去调用子元素的 measure 方法，各个子元素再递归去执行这个流程，完成测量。</p>
</blockquote>
<h5 id="3-1-View-的-measure-过程"><a href="#3-1-View-的-measure-过程" class="headerlink" title="3.1 View 的 measure 过程"></a>3.1 View 的 measure 过程</h5><p>View 的 measure 过程由其 measure 方法控制，measure 方法内部会调用 onMeasure 方法完成具体的测量。</p>
<center><strong>View # onMeasure(int widthMeasureSpec, int heightMeasureSpec)</strong></center><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><center><strong>View # getDefaultSize(int size, int measureSpec)</strong></center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> result = size;</div><div class="line">       <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">       <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">       <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">       <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">           result = size;</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">       <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">           result = specSize;</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>对 onMeasure 方法内调用的方法进行解释：</p>
<ul>
<li>getSuggestedMinimumWidth / Height()：返回视图应使用的建议最小宽度/高度<br>内部逻辑：如果 View 没有设置背景，那么返回 android:minWidth / minHeight 属性指定的值，这个值可以为 0 ；如果设置了背景，则返回 android:minWidth / minHeight 和背景的最小宽度/高度这两者中的最大值。<br><br></li>
<li>getDefaultSize(int size, int measureSpec)：该方法内部逻辑也比较简单，UNSPECIFIED 的情况我们不需要关注，在 AT_MOST 或 EXACTLY 模式下返回值 即为 width / heightMeasureSpec 的 SpecSize。<br><br></li>
<li>setMeasuredDimension(int measuredWidth, int measuredHeight)：该方法返回时我们就可以在 onLayout 中通过 getMeasureWidth 方法获得测量宽高了。</li>
</ul>
<h5 id="3-2-ViewGroup-的-measure-过程"><a href="#3-2-ViewGroup-的-measure-过程" class="headerlink" title="3.2 ViewGroup 的 measure 过程"></a>3.2 ViewGroup 的 measure 过程</h5><p> ViewGroup 除了完成自己的测量过程外，还要遍历去调用子元素的 measure 方法，各个子元素再递归去执行这个流程。</p>
<blockquote>
<p>和 View 不同的是，ViewGroup 是一个抽象类，因此它没有重写 View 的 onMeasure 方法，但它提供了一个叫 measureChildren 的方法。</p>
</blockquote>
 <center><strong>ViewGroup # measureChildren(int widthMeasureSpec, int heightMeasureSpec)</strong></center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</div><div class="line">      <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">          <span class="keyword">final</span> View child = children[i];</div><div class="line">          <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">              measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
 <center><strong>ViewGroup # measureChild(View child, int parentWidthMeasureSpec,</strong><br>            <strong>int parentHeightMeasureSpec)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line">        <span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">            mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">            mPaddingTop + mPaddingBottom, lp.height);</div><div class="line"></div><div class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>measureChildren 方法会遍历子 View，并对子 View 执行测量流程，子 View 的测量流程调用在 measureChild 方法中开启， measureChild 方法内部会调用 getChildMeasureSpec 方法获得子 View 的 MeasureSpec ，<strong>然后调用子 View 的 measure 方法</strong>(如果子 View 为 ViewGroup 则递归回到 ViewGroup 的 measure 过程，如果子 View 为原始的 View，则到了 View 的 measure 过程，这一次递归即将结束)。<br><br>ViewGroup 作为抽象类并没有定义其测量的具体过程（抽象类只能实例化其子类，子类必须重写从 View 中继承来的 onMeasure 方法），比如 Linearlayout、RelativeLayout、FrameLayout等。<br><br>#### 4 layout 过程<br><br>&gt;Layout 的 作用是 ViewGroup 用来确定子元素的位置，当 ViewGroup 的位置确定后，它在 onLayout 中会遍历所有子元素并调用其 layout 方法，在 layout 方法中 onLayout 方法又会被调用。<br><br>##### 4.1 View 的 layout 过程<br><br>View 的 layout 方法定义如下：<br><code>public void layout(int l, int t, int r, int b)</code><br>&gt;layout 方法中会通过 setFrame 方法来设定 View 的四个顶点的位置，即初始化 mLeft，mRight，mTop 和 mBottom，View 的四个顶点一旦确定，那么 View 在父容器中的位置也就确定了。<br><br>在 layout 方法中会调用 onLayout 方法，但 View 基类并没有对 onLayout 方法定义具体的实现，onLayout 方法在 View 中的定义如下：<br> <center><strong>View # onLayout(boolean changed, int left, int top, int right, int bottom)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br><br>##### 4.2 ViewGroup 的 layout 过程<br><br> <center><strong>ViewGroup # layout(int l, int t, int r, int b)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="keyword">null</span> || !mTransition.isChangingLayout())) &#123;</div><div class="line">        <span class="keyword">if</span> (mTransition != <span class="keyword">null</span>) &#123;</div><div class="line">            mTransition.layoutChange(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">super</span>.layout(l, t, r, b);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// record the fact that we noop'd it; request layout when transition finishes</span></div><div class="line">        mLayoutCalledWhileSuppressed = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>ViewGroup 的 layout 方法 调用了 View 的 layout 方法（<code>super.layout(l, t, r, b)</code>），而 View 的 layout 方法内部会调用 onLayout 方法，ViewGroup 覆写了 View 的 onLayout 方法，使 onLayout 方法成为抽象方法，那么 ViewGroup 的子类就必须提供 onLayout 的具体实现。即 ViewGroup 的 layout 依赖于抽象方法 onLayout（细节依赖抽象——依赖倒置原则）。<br><br>ViewGroup 和 View 对 onLayout 方法的声明如下：<br> <center><strong>ViewGroup # onLayout(boolean changed, int left, int top, int right, int bottom)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed,</span></span></div><div class="line">           <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b);</div></pre></td></tr></table></figure><br><br>ViewGroup 完成自己的 layout 的同时需要遍历所有子元素开启子元素的 layout 过程，但开启子元素的 layout 过程这一点在 ViewGroup 基类中并没有体现，像 ViewGroup 的开启子元素的 measure 过程体现在 ViewGroup 的 measureChild 方法中，在 measureChild 方法中会调用子元素的 measure 方法。这是怎么回事呢？<br>这就又回到 ViewGroup 的 onLayout 方法上了，既然 ViewGroup 的 onLayout 方法是抽象的，那么开启子元素的 layout 过程就应该在 ViewGroup 的子类的 onLayout 方法中。举个栗子，FrameLayout 的 onLayout 方法：<br><br> <center><strong>FrameLayout# onLayout(boolean changed, int left, int top, int right, int bottom)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">    layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>看看 layoutChildren 方法。<br> <center><strong>FrameLayout# layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom, <span class="keyword">boolean</span> forceLeftGravity)</span> </span>&#123;</div><div class="line">...</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">          <span class="keyword">final</span> View child = getChildAt(i);</div><div class="line">          <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</div><div class="line">              ...</div><div class="line">              <span class="keyword">switch</span> (verticalGravity) &#123;</div><div class="line">                  <span class="keyword">case</span> Gravity.TOP:</div><div class="line">                      childTop = parentTop + lp.topMargin;</div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</div><div class="line">                      childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</div><div class="line">                      lp.topMargin - lp.bottomMargin;</div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  <span class="keyword">case</span> Gravity.BOTTOM:</div><div class="line">                      childTop = parentBottom - height - lp.bottomMargin;</div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  <span class="keyword">default</span>:</div><div class="line">                      childTop = parentTop + lp.topMargin;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              child.layout(childLeft, childTop, childLeft + width, childTop + height);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><br><br>可以看到在 layoutChildren 方法中遍历了 FrameLayout 的子元素，并调用子元素的 layout 方法。<br><br>#### 5 draw 过程<br><br>View 的 draw 过程遵循如下步骤：<br><br>&gt;1. 绘制背景：background.draw(canvas)<br>&gt;2. 绘制自己：onDraw<br>&gt;3. 绘制children：dispatchDraw<br>&gt;4. 绘制装饰：onDrawScrollBars<br><br>该流程在 draw 源码中可以明显看出：<br><center><strong>View # draw(Canvas canvas) </strong></center><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CallSuper</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</div><div class="line">               (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</div><div class="line">       mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</div><div class="line"></div><div class="line">       <span class="comment">/*</span></div><div class="line">        * Draw traversal performs several drawing steps which must be executed</div><div class="line">        * in the appropriate order:</div><div class="line">        *</div><div class="line">        *      1. Draw the background</div><div class="line">        *      2. If necessary, save the canvas' layers to prepare for fading</div><div class="line">        *      3. Draw view's content</div><div class="line">        *      4. Draw children</div><div class="line">        *      5. If necessary, draw the fading edges and restore layers</div><div class="line">        *      6. Draw decorations (scrollbars for instance)</div><div class="line">        */</div><div class="line"></div><div class="line">       <span class="comment">// Step 1, draw the background, if needed</span></div><div class="line">       <span class="keyword">int</span> saveCount;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (!dirtyOpaque) &#123;</div><div class="line">           drawBackground(canvas);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</div><div class="line">       <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</div><div class="line">       <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</div><div class="line">       <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</div><div class="line">           <span class="comment">// Step 3, draw the content</span></div><div class="line">           <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</div><div class="line"></div><div class="line">           <span class="comment">// Step 4, draw the children</span></div><div class="line">           dispatchDraw(canvas);</div><div class="line"></div><div class="line">           <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></div><div class="line">           <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</div><div class="line">               mOverlay.getOverlayView().dispatchDraw(canvas);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></div><div class="line">           onDrawForeground(canvas);</div><div class="line"></div><div class="line">           <span class="comment">// we're done...</span></div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">      ...</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br><br>draw 方法会依次调用上述流程的对应方法完成自己的绘制和子元素的绘制，这里重点来看看 dispatchDraw 方法，即 draw 流程的分发。<br><br><center><strong>View # dispatchDraw(Canvas canvas) </strong></center><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure><br><br>可见 View 并没有对 dispatchDraw 方法提供实现，说明其实现与具体的 View 相关。<br><br>##### 5.1 ViewGroup 的 dispatchDraw 方法<br><br>ViewGroup 对 dispatchDraw 方法定义了具体的实现，在方法内部调用了 drawChild 方法<br><br><center><strong>ViewGroup# drawChild(Canvas canvas, View child, long drawingTime) </strong></center><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br><br>可以看到在 drawChild 方法中会去调用子元素的 draw 方法开启子元素的 draw 流程。<br><br>———-<br>文章大部分内容摘抄自《Android 开发艺术探索》第 4 章 —— View 的工作原理，加上部分自己的理解和总结，可能有错误，欢迎指正。<br><br><center><strong><em>END</em> </strong></center>

</center></center></center></center></center></center>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/09/Android-View-的事件分发机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="James Duan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Duan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/09/Android-View-的事件分发机制/" itemprop="url">Android：View 的事件分发机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-09T22:33:29+08:00">
                2017-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Android-View的事件分发机制"><a href="#Android-View的事件分发机制" class="headerlink" title="Android-View的事件分发机制"></a>Android-View的事件分发机制</h4><ul>
<li>View 的事件由 MotionEvent 类表示，MotionEvent 定义了大量的常量来表示用户的手指（鼠标、手写笔、轨迹球）在屏幕上的各种状态。View 的事件分发机制指的就是 View （ViewGroup、Button等）在复杂的层级关系里对 MotionEvent 事件的分配和处理规则。</li>
<li>事件序列：当一次手指触摸屏幕行为开始，往往后续会连续触发一连串的事件，如：DOWN -&gt; ..MOVE.. -&gt; UP。也可以说从 <em>ACTION_DOWN</em> 开始到  <em>ACTION_UP</em> 事件到达的过程为一次事件序列。</li>
</ul>
<h5 id="一-MotionEvent"><a href="#一-MotionEvent" class="headerlink" title="一. MotionEvent"></a>一. MotionEvent</h5><p>MotionEvent 类的定义如下：<br><code>public final class MotionEvent extends InputEvent implements Parcelable</code><br>该类继承了 InputEvent （抽象类，输入事件的表示类），同时该类是可序列化的。</p>
<h6 id="1-1-常见的事件状态："><a href="#1-1-常见的事件状态：" class="headerlink" title="1.1 常见的事件状态："></a>1.1 常见的事件状态：</h6><ul>
<li><code>ACTION_DOWN</code><br>手指刚接触屏幕，按下的手势已经开始，此次事件序列的起始位置（坐标）被赋值。<br>-<code>ACTION_UP</code><br>手指从屏幕松开的一瞬间，按下的手势结束，此次事件序列结束，最终的结束位置（坐标）决定。</li>
<li><code>ACTION_MOVE</code><br>在接收到 ACTION_DOWN 之后，接收到 ACTION_UP 之前，在手指和屏幕保持接触的前提下手指的位置（坐标）发生了改变。</li>
</ul>
<h5 id="1-2-默认的规则"><a href="#1-2-默认的规则" class="headerlink" title="1.2 默认的规则"></a>1.2 默认的规则</h5><p><a id="rule"></a></p>
<blockquote>
<p>规则 1</p>
<blockquote>
<p>ViewGroup 默认不拦截任何事件。Android 源码中 ViewGroup 的 onInterceptTouchEvent 方法默认返回 false</p>
</blockquote>
<p>规则 2</p>
<blockquote>
<p>View 的 onTouchEvent 默认都会消耗事件（返回 true） ，除非他是不可点击的（clickable 、 longClickable 和 contextClickable 都为 false）。</p>
</blockquote>
<p>规则 3</p>
<blockquote>
<p>onCLick 会发生的前提是当前 View 是可点击的，并且它收到了 DOWN 和 UP 事件。</p>
</blockquote>
</blockquote>
<h5 id="二-触摸事件涉及到的主要方法"><a href="#二-触摸事件涉及到的主要方法" class="headerlink" title="二.  触摸事件涉及到的主要方法"></a>二.  触摸事件涉及到的主要方法</h5><ul>
<li><code>public boolean dispatchTouchEvent(MotionEvent event)</code><br>事件分发逻辑处理的主要方法，如果触摸事件传递到当前 View 那么该方法一定会被调用，返回结果受当前 View 的 onTouchEvent 和下级 View 的 dispatchTouchEvent 方法的影响，表示是否消耗掉当前事件。</li>
<li><code>public boolean onInterceptTouchEvent(MotionEvent event)</code><br>在 dispatchTouchEvent 方法中调用，用来判断是否拦截某个事件，如果当前 View 拦截了某个事件，那么在同一个事件序列中该方法不会再调用，返回结果表示是否拦截当前事件。 </li>
<li><code>public boolean onTouchEvent(MotionEvent event)</code><br>在 dispatchTouchEvent 方法中调用，用来处理触摸事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前 View 无法再次接收到事件。</li>
</ul>
<h5 id="三-事件分发过程"><a href="#三-事件分发过程" class="headerlink" title="三. 事件分发过程"></a>三. 事件分发过程</h5><h6 id="3-1-ViewGroup-的-dispatchTouchEvent-方法"><a href="#3-1-ViewGroup-的-dispatchTouchEvent-方法" class="headerlink" title="3.1 ViewGroup 的 dispatchTouchEvent 方法"></a>3.1 ViewGroup 的 dispatchTouchEvent 方法</h6><ol>
<li>对于一个根 ViewGroup 来说，点击事件产生后，首先会传递给它，这时它的<code>dispatchTouchEvent</code>就会被调用：</li>
</ol>
<ul>
<li>如果这个 ViewGroup 的 <code>onInterceptTouchEvent</code>方法返回 true就表示它要拦截当前事件，接着事件就会交给这个 ViewGroup 处理，即它的 <code>onTouchEvent</code>方法就会被调用</li>
<li>如果这个 ViewGroup 的 <code>onInterceptTouchEvent</code> 方法返回 false 就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的 <code>dispatchTouchEvent</code>方法就会被调用，如此反复直到最终事件被处理。</li>
</ul>
<ol>
<li>参照源码加深理解<br>源码 <code>dispatchTouchEvent</code> 方法比较复杂，这里分段从前往后选取关键部分依次进行分析。</li>
</ol>
<p>（1）判断当前 View（ViewGroup）是否拦截事件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">		-------------ViewGroup#dispatchTouchEvent---------------</div><div class="line"> public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class="line"> ...</div><div class="line">// Check for interception.</div><div class="line">            final boolean intercepted;</div><div class="line">            if (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                    || mFirstTouchTarget != null) &#123;</div><div class="line">                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</div><div class="line">                if (!disallowIntercept) &#123;</div><div class="line">                    intercepted = onInterceptTouchEvent(ev);</div><div class="line">                    ev.setAction(action); // restore action in case it was changed</div><div class="line">                &#125; else &#123;</div><div class="line">                    intercepted = false;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                // There are no touch targets and this action is not an initial down</div><div class="line">                // so this view group continues to intercept touches.</div><div class="line">                intercepted = true;</div><div class="line">            &#125;</div><div class="line">            ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一句一句进行分析：</p>
<center><font size="+2"><strong><code>if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)</code></strong>:</font></center><br>如果当前事件为 <em>ACTION_DOWN</em>，并且<code>mFirstTouchTarget</code>不为空，就进行后面的操作。那么<code>mFirstTouchTarget</code>是什么呢？<br>&gt;根据 ViewGroup 的 onDispatchTouchEvent 方法后面部分得分析可知，当事件由 <em>ViewGroup</em>的子元素成功处理时（ViewGroup）没有进行拦截，mFirstTouchTarget 将被赋值，并指向其子元素，反过来，如果<em>ViewGroup</em>对事件进行拦截，mFirstTouchTarget != null 就不成立。<br><br>大家可能疑惑这句将<code>mFirstTouchTarget</code>是否为空作为判断条件，而<code>mFirstTouchTarget</code>的赋值却在这个<code>if()</code>判断之后，那<code>mFirstTouchTarget</code>不是一定为 null！<br>    <code>mFirstTouchTarget</code>作为全局变量，当<code>dispatchTouchEvent</code><strong>第一次</strong>被调用时其值一定为空，而<code>actionMasked == MotionEvent.ACTION_DOWN</code>一定为 true ，这时，ViewGroup 的 <code>onInterceptTouchEvent</code>会被调用，如果其返回为 true，表示要拦截（那么 intercepted 为 true，mFirstTouchTarget 将不被赋值为空），那么此次的 <em>ACTION_DOWN</em>事件就被拦截，<em>ACTION_DOWN</em>是一次事件序列的开始，那么当此次事件序列的下一个事件到达调用<code>dispatchTouchEvent</code>方法并运行到<code>if()</code>时，该<code>if()</code>将为 false（此时 <code>actionMasked != MotionEvent.ACTION_DOWN</code>且<code>mFirstTouchTarget  == null</code>），则 <code>intercepted = true</code>，这就得出一个结论：<br>&gt;结论 1<br>&gt;&gt;某个 View 一旦决定拦截，那么这一事件序列都只能由它来处理（如果事件序列能够传递给他的话），并且它的 onInterceptTouchEvent 不会再被调用。<br><br><center><font size="+2"><strong><code>final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;if (!disallowIntercept) {...</code></strong></font></center><br>这句中使用到了一个标记位<code>FLAG_DISALLOW_INTERCEPT</code>，那么这个标记位是否启用是由谁决定、怎么决定的呢？<br>这里我们讨论的是 ViewGroup 的    <code>dispatchTouchEvent</code> 方法，<code>dispatchTouchEvent</code> 方法如果不拦截事件，那么 ViewGroup 就会将事件传递给它的子 View，这时子 View 可以通过其所在容器（父视图 ViewGroup）的引用调用 ViewGroup 的 <code>requestDisallowInterceptTouchEvent(boolean disallowIntercept)</code>方法改变 ViewGroup 的行为（启用或停用<code>FLAG_DISALLOW_INTERCEPT</code>标记位），使 ViewGroup 不再拦截除 ACTION_DOWN 以外的其它事件。<br><br>为什么说除了 ACTION_DOWN 以外的事件呢？<br>&gt;这是因为 ViewGroup 在分发事件时，如果是 ACTION_DOWN 事件就会重置 <code>FLAG_DISALLOW_INTERCEPT</code>标记位，使该标记位失效，即当面对 ACTION_DOWN 事件时，ViewGroup 总会调用自己的 <code>onInterceptTouchEvent</code>方法来询问自己是否要拦截事件。这一点在源码中也有体现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Handle an initial down.</span></div><div class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">                <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></div><div class="line">                <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></div><div class="line">                <span class="comment">// due to an app switch, ANR, or some other state change.</span></div><div class="line">                cancelAndClearTouchTargets(ev);</div><div class="line">                resetTouchState();</div><div class="line">            &#125;</div></pre></td></tr></table></figure><br><br>&gt;结论 2<br>&gt;&gt;事件传递是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子元素，通过 requestDisallowInterceptTouchEvent 方法可以在子元素中干预父元素的事件分发过程，但是 ACTION_DOWN 事件除外。<br><br>（2）ViewGroup 不拦截事件，将事件分发给子 View<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">       -------------ViewGroup#dispatchTouchEvent---------------</div><div class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class="line">...</div><div class="line">						final View[] children = mChildren;</div><div class="line">                        for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</div><div class="line">                            final int childIndex = getAndVerifyPreorderedIndex(</div><div class="line">                                    childrenCount, i, customOrder);</div><div class="line">                            final View child = getAndVerifyPreorderedView(</div><div class="line">                                    preorderedList, children, childIndex);</div><div class="line"></div><div class="line">                            // If there is a view that has accessibility focus we want it</div><div class="line">                            // to get the event first and if not handled we will perform a</div><div class="line">                            // normal dispatch. We may do a double iteration but this is</div><div class="line">                            // safer given the timeframe.</div><div class="line">                            if (childWithAccessibilityFocus != null) &#123;</div><div class="line">                                if (childWithAccessibilityFocus != child) &#123;</div><div class="line">                                    continue;</div><div class="line">                                &#125;</div><div class="line">                                childWithAccessibilityFocus = null;</div><div class="line">                                i = childrenCount - 1;</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            if (!canViewReceivePointerEvents(child)</div><div class="line">                                    || !isTransformedTouchPointInView(x, y, child, null)) &#123;</div><div class="line">                                ev.setTargetAccessibilityFocus(false);</div><div class="line">                                continue;</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            newTouchTarget = getTouchTarget(child);</div><div class="line">                            if (newTouchTarget != null) &#123;</div><div class="line">                                // Child is already receiving touch within its bounds.</div><div class="line">                                // Give it the new pointer in addition to the ones it is handling.</div><div class="line">                                newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                                break;</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            resetCancelNextUpFlag(child);</div><div class="line">                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</div><div class="line">                                // Child wants to receive touch within its bounds.</div><div class="line">                                mLastTouchDownTime = ev.getDownTime();</div><div class="line">                                if (preorderedList != null) &#123;</div><div class="line">                                    // childIndex points into presorted list, find original index</div><div class="line">                                    for (int j = 0; j &lt; childrenCount; j++) &#123;</div><div class="line">                                        if (children[childIndex] == mChildren[j]) &#123;</div><div class="line">                                            mLastTouchDownIndex = j;</div><div class="line">                                            break;</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;</div><div class="line">                                &#125; else &#123;</div><div class="line">                                    mLastTouchDownIndex = childIndex;</div><div class="line">                                &#125;</div><div class="line">                                mLastTouchDownX = ev.getX();</div><div class="line">                                mLastTouchDownY = ev.getY();</div><div class="line">                                newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">                                alreadyDispatchedToNewTouchTarget = true;</div><div class="line">                                break;</div><div class="line">                            &#125;</div><div class="line">                   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><center><font size="+2"><code>for (int i = childrenCount - 1; i &gt;= 0; i--) {...</code></font><br></center><br>将事件分发给子 View 的过程通过遍历每一个子 View，判断子 View是否能接收到事件，能就调用其 <code>dispatchTouchEvent</code>方法，若子 View 的 <code>dispatchTouchEvent</code>方法返回 false ，表示子 View 未消耗事件，则继续循环；如果子 View 的 <code>dispatchTouchEvent</code>方法返回 true，表示子 View 消耗了事件，那么<code>mFirstTouchTarget</code>将被赋值，同时结束循环。<br>- 如何判断子 View 是否能接收到事件：<br>子元素是否在播放动画<br>点击事件的坐标是否落在子元素的区域内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">if (childWithAccessibilityFocus != null) &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line">if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure><br><br>- <code>mFirstTouchTarget</code>的赋值：对应代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line"><span class="keyword">break</span>;</div></pre></td></tr></table></figure><br><br>具体的赋值在<code>addTouchTarget</code>方法内部。<br>- 遍历所有子元素都没有被处理：这包含两种情况，第一种为 ViewGroup 没有子元素，第二种是子元素处理了点击事件，但 子元素的 <code>dispatchTouchEvent</code>方法返回了false（这一般是因为子元素在<code>onTouchEvent</code>方法中返回了false），此时 ViewGroup 将自己处理事件。<br>结论：<br><a id="result3"></a><br>&gt;结论 3<br>&gt;&gt;某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN 事件（onTouchEvent返回false），那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将重新交由它的父元素去处理，即父元素的 onTouchEvent 会被调用。意思就是事件一旦交给一个 View 来处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不再交给它来处理。<br><br><br> 这个结论可以结合代码来理解：<br><strong><code>某个 View 一旦开始处理事件</code></strong>：在开始循环前各个关键变量的值应该是这样的：<br>1.<code>mFirstTouchTarget</code>一定为空<br>2.<code>intercepted</code>一定为 false<br>3.可以推出<code>actionMasked == MOtionEvent.ACTION_DOWN</code>（这里参照 3.1 的部分）。<br><br> 之后遍历子 View 开始，在确定了<strong>某一个</strong>子 View <em>CV</em> 能接收到事件后，调用<em>CV</em>的<code>dispatchTouchEvent</code>方法（<code>dispatchTransformedTouchEvent</code>方法内部）：<br> - 若<code>dispatchTouchEvent</code>返回 true ，表示<em>CV</em>消耗了<strong>ACTION_DOWN</strong>事件，这时对<code>mFirstTouchTarget</code>赋值，使其指向<em>CV</em>，并跳出循环。当此次事件序列的下一个事件到达，假设为 ACTION_MOVE，此时<code>mFirstTouchTarget != null</code>成立，如果<em>CV</em>调用了<code>requestDisallowInterceptTouchEvent</code>方法启用<code>FLAG_DISALLOW_INTERCEPT</code>标记位（<code>disallowIntercept 为 true</code>），则 <code>intercepted</code>为 false，若<code>FLAG_DISALLOW_INTERCEPT</code>标记位没有被启用，那么 ViewGroup 的 <code>onInterceptTouchEvent</code>再次调用，参考 <a href="#rule">规则 1 </a>可以知道，一般情况下<code>intercepted</code>也会为 false，那么 <strong>同一事件序列中的其他事件都会交给它处理</strong>。<br> - 若<code>dispatchTouchEvent</code>返回 false，即 <em>CV</em> 不消耗 ACTION_DOWN 事件（onTouchEvent返回false）,此时会继续往下遍历子 View，如果遍历结束都没有被处理，那么 ViewGroup 将自己处理该事件，即<strong>父元素的 onTouchEvent 会被调用</strong>。<br><br>###### 3.2 View 的 dispatchTouchEvent 方法<br><br>View 的<code>dispatchTouchEvent</code>方法要简单一些，这里的 View 不包括 ViewGroup 。<br>&gt;View（不包括 ViewGroup）做为一个单独的元素，它没有子元素无法向下传递事件，所以只能自己处理事件。<br><br>（一） 事件传递到了某一个具体的 View 那就表明该 View 能接收到触摸事件，传递过来的第一个事件一定是此次事件序列的 <code>ACTION_DOWN</code> 事件，如果 View 消耗了 <code>ACTION_DOWN</code> 事件（返回true），那么该事件序列的后续事件都会传递给他，如果没消耗 <code>ACTION_DOWN</code> ，那么它将无法收到后续事件。参考  <a href="#result3">结论 3 </a><br><br>如果 View 只想处理 <code>ACTION_DOWN</code> 事件，而不处理其他事件，那可以覆写 <code>dispatchTouchEvent</code>方法或通过设置监听器实现（<code>setOnTouchListener(OnTouchListener l)</code>），在方法中加入如下判断即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="keyword">if</span>(event.getAction() == MotionEvent.ACTION_DOWN)</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">...</div></pre></td></tr></table></figure><br><br>（二） 内部监听和外部监听<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">-------------View#dispatchTouchEvent---------------</div><div class="line"> public boolean dispatchTouchEvent(MotionEvent event) &#123;</div><div class="line">...</div><div class="line">        if (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">            if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</div><div class="line">                result = true;</div><div class="line">            &#125;</div><div class="line">            //noinspection SimplifiableIfStatement</div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            if (li != null &amp;&amp; li.mOnTouchListener != null</div><div class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</div><div class="line">                result = true;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class="line">                result = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">...</div><div class="line">        return result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br><br>&gt;从源码可以看出，首先会判断有没有设置 OnTouchListener ，如果有，并且 OnTouchListener 中的 onTouch 方法返回 true，那么 onTouchEvent 就不会被调用，可见 OnTouchListener 的优先级高于 OnTouchEvent，这样做的好处是方便在外界处理触摸事件。<br><br>所以如果想屏蔽 View 默认的触摸事件处理只需为 View 设置监听器并返回 true 即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">view.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</div><div class="line">	  <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line"> &#125;);</div></pre></td></tr></table></figure><br><br>（三）View 的 onTouchEvent 对 DISEABLED 的处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">     <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class="line">         <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">             setPressed(<span class="keyword">false</span>);</div><div class="line">         &#125;</div><div class="line">         <span class="comment">// A disabled view that is clickable still consumes the touch</span></div><div class="line">         <span class="comment">// events, it just doesn't respond to them.</span></div><div class="line">         <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</div><div class="line">                 || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</div><div class="line">                 || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</div><div class="line">     &#125;</div><div class="line">...</div><div class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><br><br>&gt;从源码可看出，当 View 处于不可用状态时，只要 CLICKABLE ，LONG_CLICKABLE 和 CONTEXT_CLICKABLE  有一者为 true，onTouchEvent 就会返回 true，即消耗事件。<br><br>这里有个<code>CONTEXT_CLICKABLE</code>，这个常量指的又是什么呢？<br><code>CONTEXT_CLICKABLE</code>是 Android SDK 23 （Android 6.0）加入的，表示触控笔上下文单击（触控笔按钮）和鼠标右键单击是否可用。为其设置监听器时应使用 onContextClick 代替 onStylusButtonPress。<br><br>（四）View 的 onTouchEvent 对点击事件的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">      <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">             (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</div><div class="line">             (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</div><div class="line">       <span class="keyword">switch</span> (action) &#123;</div><div class="line">       <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">        ...</div><div class="line">                         <span class="keyword">if</span> (!focusTaken) &#123;</div><div class="line">                             <span class="comment">// Use a Runnable and post this rather than calling</span></div><div class="line">                             <span class="comment">// performClick directly. This lets other visual state</span></div><div class="line">                             <span class="comment">// of the view update before click actions start.</span></div><div class="line">                             <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</div><div class="line">                                 mPerformClick = <span class="keyword">new</span> PerformClick();</div><div class="line">                             &#125;</div><div class="line">                             <span class="keyword">if</span> (!post(mPerformClick)) &#123;</div><div class="line">                                 performClick();</div><div class="line">                             &#125;</div><div class="line">                         &#125;</div><div class="line">                     &#125;</div><div class="line">...</div><div class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><br><br>&gt;当 ACTION_UP 事件到达时，会触发 performClick 方法，如果 View 设置了 OnClickListener，那么 performClick 内部会调用它的 onClick 方法。<br><br>注释中说明了要使用 post 方法通过 Handler 执行 onClick，这让我们能够在 onClick 执行之前看到 View 的状态更新。<br><br>（五）CLICKABLE ，LONG_CLICKABLE 和 CONTEXT_CLICKABLE  的设置<br>&gt;View 的 LONG_CLICKABLE 属性默认为 false ，而 CLICKABLE 属性是否为 false 和具体的 View 相关，确切来说是可点击的 View 的 CLICKABLE 为 true ，不可点击的 View 的 CLICKABLE 为 false，比如 Button 是可点击的，而 TextView 是不可点击 的。通过 setClickable 、 setLongClickable 和 setContextClickable 可修改三者的值。另外，setOnClickListener、setOnLongClickListener 和 setOnContextClickListener 方法内部会自动将 View 的对应属性的 XXXable 值改为 true。<br><br>文章大部分摘抄自《Android 开发艺术探索》，第三章 3.4 节 —— View的事件分发机制，加上部分自己的理解，可能有错误，欢迎指正。<br><center><u><b><em>END</em></b></u></center>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="James Duan" />
          <p class="site-author-name" itemprop="name">James Duan</p>
           
              <p class="site-description motion-element" itemprop="description">￥.￥</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/DuanJiaNing" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CAFE_BABE_Duan" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="2217611834" target="_blank" title="QQ">
                  
                    <i class="fa fa-fw fa-qq"></i>
                  
                  QQ
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/aimeimeits" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-blog"></i>
                  
                  CSDN
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="aimeimeits@gmail.com" target="_blank" title="email">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  email
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  Thu May 18 2017 08:00:00 GMT+0800 (中国标准时间) - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">James Duan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
