<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Android-View-的事件分发机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/18/Android-View-的事件分发机制/" class="article-date">
  <time datetime="2017-05-18T08:41:21.862Z" itemprop="datePublished">2017-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: Android-View 的事件分发机制</p>
<h2 id="date-2017-04-16-16-47-11"><a href="#date-2017-04-16-16-47-11" class="headerlink" title="date: 2017-04-16 16:47:11"></a>date: 2017-04-16 16:47:11</h2><h4 id="Android-View的事件分发机制"><a href="#Android-View的事件分发机制" class="headerlink" title="Android-View的事件分发机制"></a>Android-View的事件分发机制</h4><ul>
<li>View 的事件由 MotionEvent 类表示，MotionEvent 定义了大量的常量来表示用户的手指（鼠标、手写笔、轨迹球）在屏幕上的各种状态。View 的事件分发机制指的就是 View （ViewGroup、Button等）在复杂的层级关系里对 MotionEvent 事件的分配和处理规则。</li>
<li>事件序列：当一次手指触摸屏幕行为开始，往往后续会连续触发一连串的事件，如：DOWN -&gt; ..MOVE.. -&gt; UP。也可以说从 <em>ACTION_DOWN</em> 开始到  <em>ACTION_UP</em> 事件到达的过程为一次事件序列。<h5 id="一-MotionEvent"><a href="#一-MotionEvent" class="headerlink" title="一. MotionEvent"></a>一. MotionEvent</h5>MotionEvent 类的定义如下：<br><code>public final class MotionEvent extends InputEvent implements Parcelable</code><br>该类继承了 InputEvent （抽象类，输入事件的表示类），同时该类是可序列化的。<h6 id="1-1-常见的事件状态："><a href="#1-1-常见的事件状态：" class="headerlink" title="1.1 常见的事件状态："></a>1.1 常见的事件状态：</h6></li>
<li><code>ACTION_DOWN</code><br>手指刚接触屏幕，按下的手势已经开始，此次事件序列的起始位置（坐标）被赋值。<br>-<code>ACTION_UP</code><br>手指从屏幕松开的一瞬间，按下的手势结束，此次事件序列结束，最终的结束位置（坐标）决定。</li>
<li><code>ACTION_MOVE</code><br>在接收到 ACTION_DOWN 之后，接收到 ACTION_UP 之前，在手指和屏幕保持接触的前提下手指的位置（坐标）发生了改变。<h5 id="1-2-默认的规则"><a href="#1-2-默认的规则" class="headerlink" title="1.2 默认的规则"></a>1.2 默认的规则</h5><a id="rule"></a><blockquote>
<p>规则 1</p>
<blockquote>
<p>ViewGroup 默认不拦截任何事件。Android 源码中 ViewGroup 的 onInterceptTouchEvent 方法默认返回 false</p>
</blockquote>
</blockquote>
</li>
</ul>
<blockquote>
<p>规则 2</p>
<blockquote>
<p>View 的 onTouchEvent 默认都会消耗事件（返回 true） ，除非他是不可点击的（clickable 、 longClickable 和 contextClickable 都为 false）。</p>
</blockquote>
<p>规则 3</p>
<blockquote>
<p>onCLick 会发生的前提是当前 View 是可点击的，并且它收到了 DOWN 和 UP 事件。</p>
<h5 id="二-触摸事件涉及到的主要方法"><a href="#二-触摸事件涉及到的主要方法" class="headerlink" title="二.  触摸事件涉及到的主要方法"></a>二.  触摸事件涉及到的主要方法</h5><ul>
<li><code>public boolean dispatchTouchEvent(MotionEvent event)</code><br>事件分发逻辑处理的主要方法，如果触摸事件传递到当前 View 那么该方法一定会被调用，返回结果受当前 View 的 onTouchEvent 和下级 View 的 dispatchTouchEvent 方法的影响，表示是否消耗掉当前事件。</li>
<li><code>public boolean onInterceptTouchEvent(MotionEvent event)</code><br>在 dispatchTouchEvent 方法中调用，用来判断是否拦截某个事件，如果当前 View 拦截了某个事件，那么在同一个事件序列中该方法不会再调用，返回结果表示是否拦截当前事件。 </li>
<li><code>public boolean onTouchEvent(MotionEvent event)</code><br>在 dispatchTouchEvent 方法中调用，用来处理触摸事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前 View 无法再次接收到事件。<h5 id="三-事件分发过程"><a href="#三-事件分发过程" class="headerlink" title="三. 事件分发过程"></a>三. 事件分发过程</h5><h6 id="3-1-ViewGroup-的-dispatchTouchEvent-方法"><a href="#3-1-ViewGroup-的-dispatchTouchEvent-方法" class="headerlink" title="3.1 ViewGroup 的 dispatchTouchEvent 方法"></a>3.1 ViewGroup 的 dispatchTouchEvent 方法</h6></li>
</ul>
<ol>
<li>对于一个根 ViewGroup 来说，点击事件产生后，首先会传递给它，这时它的<code>dispatchTouchEvent</code>就会被调用：</li>
</ol>
<ul>
<li>如果这个 ViewGroup 的 <code>onInterceptTouchEvent</code>方法返回 true就表示它要拦截当前事件，接着事件就会交给这个 ViewGroup 处理，即它的 <code>onTouchEvent</code>方法就会被调用</li>
<li>如果这个 ViewGroup 的 <code>onInterceptTouchEvent</code> 方法返回 false 就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的 <code>dispatchTouchEvent</code>方法就会被调用，如此反复直到最终事件被处理。</li>
</ul>
<ol>
<li>参照源码加深理解<br>源码 <code>dispatchTouchEvent</code> 方法比较复杂，这里分段从前往后选取关键部分依次进行分析。</li>
</ol>
</blockquote>
</blockquote>
<p>（1）判断当前 View（ViewGroup）是否拦截事件</p>
<pre><code class="java">        -------------ViewGroup#dispatchTouchEvent---------------
 public boolean dispatchTouchEvent(MotionEvent ev) {
 ...
// Check for interception.
            final boolean intercepted;
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
            }
            ...
}
</code></pre>
<p>一句一句进行分析：</p>
<p><center><font size="+2"><strong><code>if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)</code></strong>:</font></center><br>如果当前事件为 <em>ACTION_DOWN</em>，并且<code>mFirstTouchTarget</code>不为空，就进行后面的操作。那么<code>mFirstTouchTarget</code>是什么呢？</p>
<blockquote>
<p>根据 ViewGroup 的 onDispatchTouchEvent 方法后面部分得分析可知，当事件由 <em>ViewGroup</em>的子元素成功处理时（ViewGroup）没有进行拦截，mFirstTouchTarget 将被赋值，并指向其子元素，反过来，如果<em>ViewGroup</em>对事件进行拦截，mFirstTouchTarget != null 就不成立。</p>
</blockquote>
<p>大家可能疑惑这句将<code>mFirstTouchTarget</code>是否为空作为判断条件，而<code>mFirstTouchTarget</code>的赋值却在这个<code>if()</code>判断之后，那<code>mFirstTouchTarget</code>不是一定为 null！<br>    <code>mFirstTouchTarget</code>作为全局变量，当<code>dispatchTouchEvent</code><strong>第一次</strong>被调用时其值一定为空，而<code>actionMasked == MotionEvent.ACTION_DOWN</code>一定为 true ，这时，ViewGroup 的 <code>onInterceptTouchEvent</code>会被调用，如果其返回为 true，表示要拦截（那么 intercepted 为 true，mFirstTouchTarget 将不被赋值为空），那么此次的 <em>ACTION_DOWN</em>事件就被拦截，<em>ACTION_DOWN</em>是一次事件序列的开始，那么当此次事件序列的下一个事件到达调用<code>dispatchTouchEvent</code>方法并运行到<code>if()</code>时，该<code>if()</code>将为 false（此时 <code>actionMasked != MotionEvent.ACTION_DOWN</code>且<code>mFirstTouchTarget  == null</code>），则 <code>intercepted = true</code>，这就得出一个结论：</p>
<blockquote>
<p>结论 1 </p>
<blockquote>
<p>某个 View 一旦决定拦截，那么这一事件序列都只能由它来处理（如果事件序列能够传递给他的话），并且它的 onInterceptTouchEvent 不会再被调用。</p>
</blockquote>
</blockquote>
<p><center><font size="+2"><strong><code>final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;if (!disallowIntercept) {...</code></strong></font></center><br>这句中使用到了一个标记位<code>FLAG_DISALLOW_INTERCEPT</code>，那么这个标记位是否启用是由谁决定、怎么决定的呢？<br>这里我们讨论的是 ViewGroup 的    <code>dispatchTouchEvent</code> 方法，<code>dispatchTouchEvent</code> 方法如果不拦截事件，那么 ViewGroup 就会将事件传递给它的子 View，这时子 View 可以通过其所在容器（父视图 ViewGroup）的引用调用 ViewGroup 的 <code>requestDisallowInterceptTouchEvent(boolean disallowIntercept)</code>方法改变 ViewGroup 的行为（启用或停用<code>FLAG_DISALLOW_INTERCEPT</code>标记位），使 ViewGroup 不再拦截除 ACTION_DOWN 以外的其它事件。</p>
<p>为什么说除了 ACTION_DOWN 以外的事件呢？</p>
<blockquote>
<p>这是因为 ViewGroup 在分发事件时，如果是 ACTION_DOWN 事件就会重置 <code>FLAG_DISALLOW_INTERCEPT</code>标记位，使该标记位失效，即当面对 ACTION_DOWN 事件时，ViewGroup 总会调用自己的 <code>onInterceptTouchEvent</code>方法来询问自己是否要拦截事件。这一点在源码中也有体现：</p>
<pre><code class="java"><span class="comment">// Handle an initial down.</span>
            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) {
                <span class="comment">// Throw away all previous state when starting a new touch gesture.</span>
                <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span>
                <span class="comment">// due to an app switch, ANR, or some other state change.</span>
                cancelAndClearTouchTargets(ev);
                resetTouchState();
            }
</code></pre>
<p>结论 2 </p>
<blockquote>
<p>事件传递是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子元素，通过 requestDisallowInterceptTouchEvent 方法可以在子元素中干预父元素的事件分发过程，但是 ACTION_DOWN 事件除外。</p>
</blockquote>
</blockquote>
<p>（2）ViewGroup 不拦截事件，将事件分发给子 View </p>
<pre><code class="java">       -------------ViewGroup#dispatchTouchEvent---------------
public boolean dispatchTouchEvent(MotionEvent ev) {
...
                        final View[] children = mChildren;
                        for (int i = childrenCount - 1; i &gt;= 0; i--) {
                            final int childIndex = getAndVerifyPreorderedIndex(
                                    childrenCount, i, customOrder);
                            final View child = getAndVerifyPreorderedView(
                                    preorderedList, children, childIndex);

                            // If there is a view that has accessibility focus we want it
                            // to get the event first and if not handled we will perform a
                            // normal dispatch. We may do a double iteration but this is
                            // safer given the timeframe.
                            if (childWithAccessibilityFocus != null) {
                                if (childWithAccessibilityFocus != child) {
                                    continue;
                                }
                                childWithAccessibilityFocus = null;
                                i = childrenCount - 1;
                            }

                            if (!canViewReceivePointerEvents(child)
                                    || !isTransformedTouchPointInView(x, y, child, null)) {
                                ev.setTargetAccessibilityFocus(false);
                                continue;
                            }

                            newTouchTarget = getTouchTarget(child);
                            if (newTouchTarget != null) {
                                // Child is already receiving touch within its bounds.
                                // Give it the new pointer in addition to the ones it is handling.
                                newTouchTarget.pointerIdBits |= idBitsToAssign;
                                break;
                            }

                            resetCancelNextUpFlag(child);
                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                // Child wants to receive touch within its bounds.
                                mLastTouchDownTime = ev.getDownTime();
                                if (preorderedList != null) {
                                    // childIndex points into presorted list, find original index
                                    for (int j = 0; j &lt; childrenCount; j++) {
                                        if (children[childIndex] == mChildren[j]) {
                                            mLastTouchDownIndex = j;
                                            break;
                                        }
                                    }
                                } else {
                                    mLastTouchDownIndex = childIndex;
                                }
                                mLastTouchDownX = ev.getX();
                                mLastTouchDownY = ev.getY();
                                newTouchTarget = addTouchTarget(child, idBitsToAssign);
                                alreadyDispatchedToNewTouchTarget = true;
                                break;
                            }
                   ...
}
</code></pre>
<p><center><font size="+2"><code>for (int i = childrenCount - 1; i &gt;= 0; i--) {...</code></font><br></center><br>将事件分发给子 View 的过程通过遍历每一个子 View，判断子 View是否能接收到事件，能就调用其 <code>dispatchTouchEvent</code>方法，若子 View 的 <code>dispatchTouchEvent</code>方法返回 false ，表示子 View 未消耗事件，则继续循环；如果子 View 的 <code>dispatchTouchEvent</code>方法返回 true，表示子 View 消耗了事件，那么<code>mFirstTouchTarget</code>将被赋值，同时结束循环。</p>
<ul>
<li>如何判断子 View 是否能接收到事件：<br>子元素是否在播放动画<br>点击事件的坐标是否落在子元素的区域内<pre><code>...
if (childWithAccessibilityFocus != null) {
  ...
}
if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
  ...
}
...
</code></pre></li>
<li><code>mFirstTouchTarget</code>的赋值：对应代码为：<pre><code class="java">newTouchTarget = addTouchTarget(child, idBitsToAssign);
alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;
<span class="keyword">break</span>;
</code></pre>
具体的赋值在<code>addTouchTarget</code>方法内部。</li>
<li>遍历所有子元素都没有被处理：这包含两种情况，第一种为 ViewGroup 没有子元素，第二种是子元素处理了点击事件，但 子元素的 <code>dispatchTouchEvent</code>方法返回了false（这一般是因为子元素在<code>onTouchEvent</code>方法中返回了false），此时 ViewGroup 将自己处理事件。<br>结论：<br><a id="result3"></a><blockquote>
<p>结论 3 </p>
<blockquote>
<p>某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN 事件（onTouchEvent返回false），那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将重新交由它的父元素去处理，即父元素的 onTouchEvent 会被调用。意思就是事件一旦交给一个 View 来处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不再交给它来处理。</p>
</blockquote>
</blockquote>
</li>
</ul>
<p> 这个结论可以结合代码来理解：<br><strong><code>某个 View 一旦开始处理事件</code></strong>：在开始循环前各个关键变量的值应该是这样的：<br>1.<code>mFirstTouchTarget</code>一定为空<br>2.<code>intercepted</code>一定为 false<br>3.可以推出<code>actionMasked == MOtionEvent.ACTION_DOWN</code>（这里参照 3.1 的部分）。</p>
<p> 之后遍历子 View 开始，在确定了<strong>某一个</strong>子 View <em>CV</em> 能接收到事件后，调用<em>CV</em>的<code>dispatchTouchEvent</code>方法（<code>dispatchTransformedTouchEvent</code>方法内部）：</p>
<ul>
<li>若<code>dispatchTouchEvent</code>返回 true ，表示<em>CV</em>消耗了<strong>ACTION_DOWN</strong>事件，这时对<code>mFirstTouchTarget</code>赋值，使其指向<em>CV</em>，并跳出循环。当此次事件序列的下一个事件到达，假设为 ACTION_MOVE，此时<code>mFirstTouchTarget != null</code>成立，如果<em>CV</em>调用了<code>requestDisallowInterceptTouchEvent</code>方法启用<code>FLAG_DISALLOW_INTERCEPT</code>标记位（<code>disallowIntercept 为 true</code>），则 <code>intercepted</code>为 false，若<code>FLAG_DISALLOW_INTERCEPT</code>标记位没有被启用，那么 ViewGroup 的 <code>onInterceptTouchEvent</code>再次调用，参考 <a href="#rule">规则 1 </a>可以知道，一般情况下<code>intercepted</code>也会为 false，那么 <strong>同一事件序列中的其他事件都会交给它处理</strong>。</li>
<li>若<code>dispatchTouchEvent</code>返回 false，即 <em>CV</em> 不消耗 ACTION_DOWN 事件（onTouchEvent返回false）,此时会继续往下遍历子 View，如果遍历结束都没有被处理，那么 ViewGroup 将自己处理该事件，即<strong>父元素的 onTouchEvent 会被调用</strong>。</li>
</ul>
<h6 id="3-2-View-的-dispatchTouchEvent-方法"><a href="#3-2-View-的-dispatchTouchEvent-方法" class="headerlink" title="3.2 View 的 dispatchTouchEvent 方法"></a>3.2 View 的 dispatchTouchEvent 方法</h6><p>View 的<code>dispatchTouchEvent</code>方法要简单一些，这里的 View 不包括 ViewGroup 。</p>
<blockquote>
<p>View（不包括 ViewGroup）做为一个单独的元素，它没有子元素无法向下传递事件，所以只能自己处理事件。</p>
</blockquote>
<p>（一） 事件传递到了某一个具体的 View 那就表明该 View 能接收到触摸事件，传递过来的第一个事件一定是此次事件序列的 <code>ACTION_DOWN</code> 事件，如果 View 消耗了 <code>ACTION_DOWN</code> 事件（返回true），那么该事件序列的后续事件都会传递给他，如果没消耗 <code>ACTION_DOWN</code> ，那么它将无法收到后续事件。参考  <a href="#result3">结论 3 </a></p>
<p>如果 View 只想处理 <code>ACTION_DOWN</code> 事件，而不处理其他事件，那可以覆写 <code>dispatchTouchEvent</code>方法或通过设置监听器实现（<code>setOnTouchListener(OnTouchListener l)</code>），在方法中加入如下判断即可：</p>
<pre><code class="java">...
<span class="keyword">if</span>(event.getAction() == MotionEvent.ACTION_DOWN)
    <span class="keyword">return</span> <span class="keyword">false</span>;
...
</code></pre>
<p>（二） 内部监听和外部监听 </p>
<pre><code class="java">-------------View#dispatchTouchEvent---------------
 public boolean dispatchTouchEvent(MotionEvent event) {
...
        if (onFilterTouchEventForSecurity(event)) {
            if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) {
                result = true;
            }
            //noinspection SimplifiableIfStatement
            ListenerInfo li = mListenerInfo;
            if (li != null &amp;&amp; li.mOnTouchListener != null
                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                    &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
                result = true;
            }

            if (!result &amp;&amp; onTouchEvent(event)) {
                result = true;
            }
        }

...
        return result;
    }
</code></pre>
<blockquote>
<p>从源码可以看出，首先会判断有没有设置 OnTouchListener ，如果有，并且 OnTouchListener 中的 onTouch 方法返回 true，那么 onTouchEvent 就不会被调用，可见 OnTouchListener 的优先级高于 OnTouchEvent，这样做的好处是方便在外界处理触摸事件。</p>
</blockquote>
<p>所以如果想屏蔽 View 默认的触摸事件处理只需为 View 设置监听器并返回 true 即可。</p>
<pre><code class="java">view.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() {
      <span class="meta">@Override</span>
      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>{
          <span class="keyword">return</span> <span class="keyword">true</span>;
      }
 });
</code></pre>
<p>（三）View 的 onTouchEvent 对 DISEABLED 的处理</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>{
    ...
     <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) {
         <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) {
             setPressed(<span class="keyword">false</span>);
         }
         <span class="comment">// A disabled view that is clickable still consumes the touch</span>
         <span class="comment">// events, it just doesn't respond to them.</span>
         <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE
                 || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)
                 || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);
     }
   ...
     <span class="keyword">return</span> <span class="keyword">false</span>;
 }
</code></pre>
<blockquote>
<p>从源码可看出，当 View 处于不可用状态时，只要 CLICKABLE ，LONG_CLICKABLE 和 CONTEXT_CLICKABLE  有一者为 true，onTouchEvent 就会返回 true，即消耗事件。</p>
</blockquote>
<p>这里有个<code>CONTEXT_CLICKABLE</code>，这个常量指的又是什么呢？<br><code>CONTEXT_CLICKABLE</code>是 Android SDK 23 （Android 6.0）加入的，表示触控笔上下文单击（触控笔按钮）和鼠标右键单击是否可用。为其设置监听器时应使用 onContextClick 代替 onStylusButtonPress。</p>
<p>（四）View 的 onTouchEvent 对点击事件的实现</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>{
    ...
      <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||
             (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||
             (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {
       <span class="keyword">switch</span> (action) {
       <span class="keyword">case</span> MotionEvent.ACTION_UP:
        ...
                         <span class="keyword">if</span> (!focusTaken) {
                             <span class="comment">// Use a Runnable and post this rather than calling</span>
                             <span class="comment">// performClick directly. This lets other visual state</span>
                             <span class="comment">// of the view update before click actions start.</span>
                             <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) {
                                 mPerformClick = <span class="keyword">new</span> PerformClick();
                             }
                             <span class="keyword">if</span> (!post(mPerformClick)) {
                                 performClick();
                             }
                         }
                        }
   ...
     <span class="keyword">return</span> <span class="keyword">false</span>;
 }
</code></pre>
<blockquote>
<p>当 ACTION_UP 事件到达时，会触发 performClick 方法，如果 View 设置了 OnClickListener，那么 performClick 内部会调用它的 onClick 方法。 </p>
</blockquote>
<p>注释中说明了要使用 post 方法通过 Handler 执行 onClick，这让我们能够在 onClick 执行之前看到 View 的状态更新。</p>
<p>（五）CLICKABLE ，LONG_CLICKABLE 和 CONTEXT_CLICKABLE  的设置</p>
<blockquote>
<p>View 的 LONG_CLICKABLE 属性默认为 false ，而 CLICKABLE 属性是否为 false 和具体的 View 相关，确切来说是可点击的 View 的 CLICKABLE 为 true ，不可点击的 View 的 CLICKABLE 为 false，比如 Button 是可点击的，而 TextView 是不可点击 的。通过 setClickable 、 setLongClickable 和 setContextClickable 可修改三者的值。另外，setOnClickListener、setOnLongClickListener 和 setOnContextClickListener 方法内部会自动将 View 的对应属性的 XXXable 值改为 true。</p>
</blockquote>
<p>文章大部分摘抄自《Android 开发艺术探索》，第三章 3.4 节 —— View的事件分发机制，加上部分自己的理解，可能有错误，欢迎指正。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/18/Android-View-的事件分发机制/" data-id="cj2u6wvr700005kc08yssj59l" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/18/hello-world/" class="article-date">
  <time datetime="2017-05-18T08:29:32.670Z" itemprop="datePublished">2017-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/18/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/18/hello-world/" data-id="cj2u6wvrs00015kc0p8ztgqb8" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/18/Android-View-的事件分发机制/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/05/18/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>