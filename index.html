<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hello, girl" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="just do it.">
<meta property="og:type" content="website">
<meta property="og:title" content="Duan">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Duan">
<meta property="og:description" content="just do it.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Duan">
<meta name="twitter:description" content="just do it.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Duan</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  















  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Duan</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The more hard, the more fortunate.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            Über
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/18/Android-Android 的消息机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="James Duan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Duan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/18/Android-Android 的消息机制/" itemprop="url">Unbenannt</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-18T18:29:48+08:00">
                2017-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>title: Android 的消息机制</p>
<h2 id="date-2017-04-15-16-47-11"><a href="#date-2017-04-15-16-47-11" class="headerlink" title="date: 2017-04-15 16:47:11"></a>date: 2017-04-15 16:47:11</h2><h3 id="Android-Android-的消息机制"><a href="#Android-Android-的消息机制" class="headerlink" title="Android-Android 的消息机制"></a>Android-Android 的消息机制</h3><blockquote>
<p>Android 的消息机制主要指的是 Handler 的运行机制，Handler 是 Android 消息机制的上层接口，通过 Handler 可以轻松的将一个任务切换到 Handler 所在的线程中去执行，由于 Android 开发规范的限制，我们不能在非 UI 线程中更新 UI，同时不应该也不能在 UI 线程中进行耗时的 I/O 操作或者进行网络访问，这时就需要使用 Handler。</p>
</blockquote>
<h4 id="1-Handler、MessageQueue、Looper-概述"><a href="#1-Handler、MessageQueue、Looper-概述" class="headerlink" title="1 Handler、MessageQueue、Looper 概述"></a>1 Handler、MessageQueue、Looper 概述</h4><blockquote>
<p>Handler 的运行需要底层的 MessageQueue 和 Looper 的支撑。</p>
</blockquote>
<ul>
<li>MessageQueue：其中文翻译是“消息队列”，内部存储了一组消息（Message），虽然叫消息队列，但其内部使用的数据结构并不是队列，而是单链表。</li>
<li>Looper：Looper 会以无限循环的方式去 MessageQueue 中查找是否还有未处理的消息或新消息，有的话就处理，没有则等待。</li>
<li>ThreadLocal：Looper 中使用到了 ThreadLocal ，ThreadLocal 并不是线程，我们知道 Handler 创建时会采用当前线程的 Looper 来构造消息循环系统，那他怎么找到当前线程的 Looper 实例呢？ThreadLocal 可以在每个线程中存储同一个对象的不同副本，即不同线程可以调用同一个 ThreadLocal 实例的方法获取属于自己的 Looper 实例，</li>
</ul>
<h4 id="2-Android-消息机制概述"><a href="#2-Android-消息机制概述" class="headerlink" title="2 Android 消息机制概述"></a>2 Android 消息机制概述</h4><h5 id="2-1-ViewRootImpl"><a href="#2-1-ViewRootImpl" class="headerlink" title="2.1 ViewRootImpl"></a>2.1 ViewRootImpl</h5><blockquote>
<p>ViewRootImpl 是链接 WindowManager 和DecorView 的纽带，另外 View 的绘制也是通过ViewRootImpl 来完成的。</p>
</blockquote>
<p>它的主要作用总结如下：</p>
<ul>
<li>链接WindowManager和DecorView的纽带，更广一点可以说是Window和View之间的纽带。</li>
<li>完成View的绘制过程，包括measure、layout、draw过程。</li>
<li>向DecorView分发收到的用户发起的event事件，如按键，触屏等事件。</li>
</ul>
<p>ViewRootImpl 是View 树的树根，但它不是View，它实现了 View 与 WindowManager 之间的通信协议，<br>参考链接：<a href="http://www.2cto.com/kf/201606/519988.html" target="_blank" rel="external">Android中的ViewRootImpl类源码解析</a></p>
<h5 id="2-2-系统怎么知道你在哪里更新的-UI"><a href="#2-2-系统怎么知道你在哪里更新的-UI" class="headerlink" title="2.2 系统怎么知道你在哪里更新的 UI"></a>2.2 系统怎么知道你在哪里更新的 UI</h5><p>Android 规定开发着不能在非 UI 线程中更新 UI，如果你不遵守这个规定，那么将引发运行时异常<code>CalledFromWrongThreadException</code>，其原因在于 ViewRootImpl 对 UI 操作做了验证， ViewRootImpl 作为视图层次结构的顶部，对 UI 的访问操作大部分都会传递到 ViewRootImpl  中，ViewRootImpl 会在 checkThread 方法中检查访问操作是否在 UI 线程，不是的话就会抛出异常。</p>
<p></p><h5><center>ViewRootImpl # checkThread() </center><p></p>
<pre><code class="java"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>{
     <span class="keyword">if</span> (mThread != Thread.currentThread()) {
         <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(
                 <span class="string">"Only the original thread that created a view hierarchy can touch its views."</span>);
     }
 }
</code></pre>
<h5 id="2-3-系统为什么不允许在-UI-线程中访问-UI-呢？"><a href="#2-3-系统为什么不允许在-UI-线程中访问-UI-呢？" class="headerlink" title="2.3 系统为什么不允许在 UI 线程中访问 UI 呢？"></a>2.3 系统为什么不允许在 UI 线程中访问 UI 呢？</h5><blockquote>
<p>这是因为 Android 的 UI 控件不是线程安全的，如果在多线程中并发访问可能会导致 UI 控件处于不可预期的状态，那为什么不对 UI 控件的访问加上锁呢？缺点有两个：首先加上锁机制会让 UI 访问的逻辑变得复杂；其次锁机制会降低 UI 访问的效率，因为锁机制会阻塞某些线程的执行。</p>
</blockquote>
<h4 id="3-ThreadLocal-的工作原理"><a href="#3-ThreadLocal-的工作原理" class="headerlink" title="3 ThreadLocal 的工作原理"></a>3 ThreadLocal 的工作原理</h4><blockquote>
<p><u><b>java.lang.ThreadLocal</b></u></p>
<p>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。 </p>
<p>ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储后，只有在指定线程中可以获取到数据，对于其他线程来说则无法获取到数据。</p>
</blockquote>
<p>举个栗子：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{

    ThreadLocal&lt;Integer&gt; mLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{

        Main test = <span class="keyword">new</span> Main ();
        test.mLocal.set(<span class="number">30</span>);
        test.print(<span class="string">"thread: "</span> + Thread.currentThread().getName() + <span class="string">" "</span> + test.mLocal.get());
        test.test();

    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span> </span>{
        System.out.println(string);
    }

    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>{

        <span class="keyword">new</span> Thread(<span class="string">"Thread#1"</span>) {
            <span class="meta">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                mLocal.set(<span class="number">31</span>);
                print(<span class="string">"thread: "</span> + <span class="keyword">this</span>.getName() + <span class="string">" "</span> + mLocal.get());
            }
        }.start();


        <span class="keyword">new</span> Thread(<span class="string">"Thread#2"</span>) {
            <span class="meta">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                mLocal.set(<span class="number">32</span>);
                print(<span class="string">"thread: "</span> + <span class="keyword">this</span>.getName() + <span class="string">" "</span> + mLocal.get());
            }
        }.start();


        <span class="keyword">new</span> Thread(<span class="string">"Thread#3"</span>) {
            <span class="meta">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                mLocal.set(<span class="number">32</span>);
                print(<span class="string">"thread: "</span> + <span class="keyword">this</span>.getName() + <span class="string">" "</span> + mLocal.get());
            }
        }.start();
    }
}
</code></pre>
<p>上面的例子在执行 test 方法时，启动了三个线程，在这三个线程中分别修改了 mLocal 的值，当各自线程通过调用 ThreadLocal 的 get 方法取值时取到的值是不同的，即各个线程有属于自己的一个值。</p>
<pre><code class="dos"><span class="function">F:\<span class="title">javaStuff</span>&gt;<span class="title">javac</span> <span class="title">Main.java</span>
<span class="title">F</span>:\<span class="title">javaStuff</span>&gt;<span class="title">java</span> <span class="title">Main</span>
<span class="title">thread</span>: <span class="title">main</span> 30
<span class="title">thread</span>: <span class="title">Thread</span>#1 31
<span class="title">thread</span>: <span class="title">Thread</span>#2 32
<span class="title">thread</span>: <span class="title">Thread</span>#3 32</span>
</code></pre>
<blockquote>
<p>ThreadLocal 之所以有这么奇妙的功能，是因为不同线程访问同一个 ThreadLocal 对象的 get 方法，ThreadLocal 内部会从各自的线程中取出一个数据实体，然后再从数据实体中取得对应的 value 值。</p>
</blockquote>
<p>那这个线程私有的数据实体在哪呢？<br>先看看 ThreadLocal 的 get 方法</p>
<p></p><h5><center>JDK 1.8.0_45  ThreadLocal # get () </center><p></p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>{
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        <span class="keyword">if</span> (map != <span class="keyword">null</span>) {
            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);
            <span class="keyword">if</span> (e != <span class="keyword">null</span>)
                <span class="keyword">return</span> (T)e.value;
        }
        <span class="keyword">return</span> setInitialValue();
    }
</code></pre>
<p>可以看到这里使用了 ThreadLocalMap.Entry 来保存数据，在《Android 开发艺术探索》一书中说的是使用 ThreadLocal.Values 来保存数据，这里的不同应该是由于 JDK 版本升级过程导致的。<br>再看看在 Thread 中 对 ThreadLocalMap 的引用：</p>
<p></p><h5><center>Thread # threadLocals </center><p></p>
<pre><code class="java"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained
     * by the ThreadLocal class. */</span>
    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;
</code></pre>
<p>从 ThreadLocal 的 get方法可以知道<code>getMap(t)</code>操作会得到当前线程的 threadLocals 对象，看看 getMap 方法。</p>
<p></p><h5><center>ThreadLocal # getMap(Thread t)</center><p></p>
<pre><code class="java"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>{
        <span class="keyword">return</span> t.threadLocals;
    }
</code></pre>
<p>到这里就很清晰了，getMap 方法会返回当前线程的 threadLocals  。</p>
<h5 id="3-1-ThreadLocal-使用场景"><a href="#3-1-ThreadLocal-使用场景" class="headerlink" title="3.1 ThreadLocal 使用场景"></a>3.1 ThreadLocal 使用场景</h5><ul>
<li>当某些数据是以线程作为作用域并且不同线程具有不同的数据副本。</li>
<li>复杂逻辑下的数据传递，比如监听器的传递，有些时候一个线程中的任务过于复杂，这可能表现为函数调用栈比较深以及代码入口的多样性，在这种情况下我们又需要监听器贯穿整个线程的执行过程，这个时候该怎么办？这个时候就可以采用 ThreadLocal ，采用 ThreadLocal 可以让监听器作为线程内的全局对象，在线程内部只需调用 ThreadLocal 的 get 方法就能获得监听器。</li>
</ul>
<h4 id="4-MessageQueue-的工作原理"><a href="#4-MessageQueue-的工作原理" class="headerlink" title="4 MessageQueue 的工作原理"></a>4 MessageQueue 的工作原理</h4><p>一个 Handler 可以正常工作的线程只会有一个 MessageQueue 的实例。<br>MessageQueue 主要包含两个操作：</p>
<ul>
<li>插入：enqueueMessage</li>
<li>删除（读取）：next</li>
</ul>
<h5 id="4-1-enqueueMessage-方法"><a href="#4-1-enqueueMessage-方法" class="headerlink" title="4.1 enqueueMessage 方法"></a>4.1 enqueueMessage 方法</h5><p></p><h5><center>MessageQueue # enqueueMessage(Message msg, long when) </center><p></p>
<pre><code class="java"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>{
    ...
    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
        ...
        msg.markInUse();
        msg.when = when;
        Message p = mMessages;
        <span class="keyword">boolean</span> needWake;
        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) {
            <span class="comment">// New head, wake up the event queue if blocked.</span>
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } <span class="keyword">else</span> {
            ...
            Message prev;
            <span class="keyword">for</span> (;;) {
                prev = p;
                p = p.next;
                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) {
                    <span class="keyword">break</span>;
                }
                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) {
                    needWake = <span class="keyword">false</span>;
                }
            }
            msg.next = p; <span class="comment">// invariant: p == prev.next</span>
            prev.next = msg;
        }
        ...
    }
    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</code></pre>
<p><code>if (p == null || when == 0 || when &lt; p.when) {..</code>： 其中 p 为下一个待处理的消息，如果 p 为 null，或插入消息的执行时间为“立刻”(when  == 0)，或插入消息执行时间比下一个待处理消息早，那么插入消息就做为新的消息队列头，将其插入对头（<code>msg.next = p; mMessages = msg;</code>）。<br>若该判断不满足，即当前消息队列不为空，插入消息的执行时间不是“立刻”，则将其插入队列（按执行时间排序）。</p>
<h5 id="4-1-next-方法"><a href="#4-1-next-方法" class="headerlink" title="4.1 next 方法"></a>4.1 next 方法</h5><p></p><h5><center>MessageQueue # next() </center><p></p>
<pre><code class="java"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>{
        ...
        <span class="keyword">for</span> (;;) {
            <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) {
                Binder.flushPendingCommands();
            }

            nativePollOnce(ptr, nextPollTimeoutMillis);

            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
                <span class="comment">// Try to retrieve the next message.  Return if found.</span>
                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();
                Message prevMsg = <span class="keyword">null</span>;
                Message msg = mMessages;
                <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) {
                    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span>
                    <span class="keyword">do</span> {
                        prevMsg = msg;
                        msg = msg.next;
                    } <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());
                }
                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) {
                    <span class="keyword">if</span> (now &lt; msg.when) {
                        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span>
                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);
                    } <span class="keyword">else</span> {
                        <span class="comment">// Got a message.</span>
                        mBlocked = <span class="keyword">false</span>;
                        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) {
                            prevMsg.next = msg.next;
                        } <span class="keyword">else</span> {
                            mMessages = msg.next;
                        }
                        msg.next = <span class="keyword">null</span>;
                        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);
                        msg.markInUse();
                        <span class="keyword">return</span> msg;
                    }
                } <span class="keyword">else</span> {
                    <span class="comment">// No more messages.</span>
                    nextPollTimeoutMillis = -<span class="number">1</span>;
                }
                ...
            }
        ...
        }
    }
</code></pre>
<blockquote>
<p>可以发现 next 方法是一个无限循环方法，如果消息队列中没有消息，那么 next 方法会一直阻塞。当有新的消息到来时，next 方法会返回这条消息并将其从单链表中移除。</p>
</blockquote>
<p>MessageQueue 的 next 方法会被 Looper 的 loop 方法调用，从而使 loop 方法也成为阻塞方法。</p>
<h4 id="4-Looper-的工作原理"><a href="#4-Looper-的工作原理" class="headerlink" title="4 Looper 的工作原理"></a>4 Looper 的工作原理</h4><p>一个 Handler 可以正常工作的线程只会有一个 Looper 的实例。</p>
<blockquote>
<p>Looper 在 Android 的消息机制中扮演者消息循环的角色，具体来说就是它会不断的从 MessageQueue 中查看是否有新消息，如果有新消息就立刻处理，否则就一直阻塞在那里。</p>
</blockquote>
<p>先看看 Looper 的构造方法：</p>
<pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>{
    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);
    mThread = Thread.currentThread();
}
</code></pre>
<p>可以看到 Looper 的构造方法是私有的，即外界无法通过 new 关键字创建其实例。<br>构造方法会实例化 MessageQueue 的实例 <code>mQueue</code>。</p>
<h5 id="4-1-在非-UI-线程使用-Handler"><a href="#4-1-在非-UI-线程使用-Handler" class="headerlink" title="4.1 在非 UI 线程使用 Handler"></a>4.1 在非 UI 线程使用 Handler</h5><ul>
<li>如果想在一个子线程（非 UI 线程）中正常的使用 Handler ，就必须让当前线程拥有一个 Looper（Looper.prepare()），并且执行其 loop （Looper.loop()）方法。<pre><code class="java"><span class="keyword">private</span> Handler mHandler;
  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>{
      <span class="keyword">new</span> Thread() {
          <span class="meta">@Override</span>
          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
              mHandler = <span class="keyword">new</span> Handler();
              Looper.prepare();
              Looper.loop();
          }
      }.start();
  }
</code></pre>
</li>
<li><p>看看 Looper.prepare() 方法<br></p><h5><center>Looper # prepare() </center><p></p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>{
      prepare(<span class="keyword">true</span>);
  }

<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>{
     <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) {
         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);
     }
     sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));
 }
</code></pre>
<p><code>sThreadLocal.get()</code> 返回结果不为空表示当前线程的 Looper.prepare() 方法已经被调用过，即当前线程已存在 Looper 实例。这就可以保证一个线程只有一个Looper，同时也保证了一个线程只有一个 MessageQueue （参照 Looper 构造方法可知）。<br>这里有个关键的变量 <code>sThreadLocal</code>，看看它的声明：<br></p><h5><center>Looper # sThreadLocal  </center><p></p>
<pre><code class="java"><span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span>
  <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();
</code></pre>
<p>参照上面对 ThreadLocal 的说明就可以知道 <code>sThreadLocal.get()</code>返回的是当前线程对应的那个 Looper 对象。 </p>
</h5></h5></li>
<li><p>Looper.loop() 方法</p>
<blockquote>
<p>Looper 最重要的一个方法是 loop 方法，只有调用了 loop 后，消息循环系统才会正真的起作用。</p>
</blockquote>
<p></p><h5><center>Looper # loop() </center><p></p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>{
      <span class="keyword">final</span> Looper me = myLooper();
      <span class="keyword">if</span> (me == <span class="keyword">null</span>) {
          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);
      }
      <span class="keyword">final</span> MessageQueue queue = me.mQueue;

      <span class="comment">// Make sure the identity of this thread is that of the local process,</span>
      <span class="comment">// and keep track of what that identity token actually is.</span>
      Binder.clearCallingIdentity();
      <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();

      <span class="keyword">for</span> (;;) {
          Message msg = queue.next(); <span class="comment">// might block</span>
          <span class="keyword">if</span> (msg == <span class="keyword">null</span>) {
              <span class="comment">// No message indicates that the message queue is quitting.</span>
              <span class="keyword">return</span>;
          }

          <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span>
          <span class="keyword">final</span> Printer logging = me.mLogging;
          <span class="keyword">if</span> (logging != <span class="keyword">null</span>) {
              logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +
                      msg.callback + <span class="string">": "</span> + msg.what);
          }

          <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;
          <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) {
              Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
          }
          <span class="keyword">try</span> {
              msg.target.dispatchMessage(msg);
          } <span class="keyword">finally</span> {
              <span class="keyword">if</span> (traceTag != <span class="number">0</span>) {
                  Trace.traceEnd(traceTag);
              }
          }

          <span class="keyword">if</span> (logging != <span class="keyword">null</span>) {
              logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);
          }

          <span class="comment">// Make sure that during the course of dispatching the</span>
          <span class="comment">// identity of the thread wasn't corrupted.</span>
          <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();
          <span class="keyword">if</span> (ident != newIdent) {
              Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span>
                      + Long.toHexString(ident) + <span class="string">" to 0x"</span>
                      + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span>
                      + msg.target.getClass().getName() + <span class="string">" "</span>
                      + msg.callback + <span class="string">" what="</span> + msg.what);
          }

          msg.recycleUnchecked();
      }
  }
</code></pre>
</h5></li>
<li><code>myLooper()</code>：方法可以获得当前线程的 Looper，该方法是 public 的，在类外也可以调用。</li>
<li><code>Message msg = queue.next(); // might block</code>：next 方法在上面分析<em>MessageQueue 的工作原理</em>时已经分析过了，会next 方法是一个无限循环方法，如果消息队列中没有消息，那么 next 方法会一直阻塞。当有新的消息到来时，next 方法会返回这条消息并将其从单链表中移除。如果 next 方法返回 null，那么 loop 循环就会结束，</li>
<li><code>msg.target.dispatchMessage(msg);</code>：当 next 有消息返回时，Looper 就会处理这条消息，这里的 msg.target 时发送这条消息的 Handler 对象，这样 Handler 发送的消息最终又交给它的 dispatchMessage 方法来处理了。这里要注意的是，dispatchMessage 方法会是在创建 Handler 的线程中执行的，这样就成功的将代码逻辑切换到指定的线程中去执行。（dispatchMessage  方法将在 <u>Handler 的工作原理</u> 中分析）</li>
</ul>
<h5 id="4-2-主线程（ActivityThread-）的消息循环"><a href="#4-2-主线程（ActivityThread-）的消息循环" class="headerlink" title="4.2 主线程（ActivityThread ）的消息循环"></a>4.2 主线程（ActivityThread ）的消息循环</h5><p>Android 的主线程由 ActivityThread 类表示。</p>
<blockquote>
<p>Looper 除了 prepare 方法外，还提供了 prepareMainLooper 方法，这个方法主要是给主线程也就是 ActivityThread 创建 Looper 使用的，其本质也是通过 prepare 方法来实现的。</p>
<p>Java 程序少不了会有一个执行入口 main 方法，那 Android 程序的 main方法在哪呢？<br>其实 Android 的 main 方法被包装在 ActivityThread 类中。所有的 Android 程序都有且仅有一个ActivityThread 类的实例，ActivityThread 所在的线程即为主线程（UI 线程）。</p>
</blockquote>
<p>Android 程序 从ActivityThread 的 main 方法开始执行，调用 prepareMain 方法为主线程创建一个 Looper 和 一个 MessageQueue，然后创建一个 ActivityThread 对象，在 ActivityThread 的初始化代码中会创建一个 Handler 对象。接着 main 方法会调用 Looper.loop() 方法进入消息循环，不断地从消息队列中读取并处理消息。</p>
<p>参考链接：<br><a href="http://blog.csdn.net/lfdfhl/article/details/51279160" target="_blank" rel="external"> Android中线程那些事</a><br><a href="http://www.jianshu.com/p/0efc71f349c8" target="_blank" rel="external">ActivityThread的main方法究竟做了什么？</a></p>
<p></p><h5><center>ActivityThread  # main(String[] args)</center><p></p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
     ...
     Looper.prepareMainLooper();

     ActivityThread thread = <span class="keyword">new</span> ActivityThread();
     thread.attach(<span class="keyword">false</span>);

     <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) {
         sMainThreadHandler = thread.getHandler();
     }

     <span class="keyword">if</span> (<span class="keyword">false</span>) {
         Looper.myLooper().setMessageLogging(<span class="keyword">new</span>
                 LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));
     }

     <span class="comment">// End of event ActivityThreadMain.</span>
     Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
     Looper.loop();

     <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);
 }
</code></pre>
<p>这里就产生了一个挺有趣的问题：<u><b>ActivityThread 的 main 方法会在 loop 方法处不断循环，没有要处理的消息就会<strong>阻塞</strong>，那为什么这里的阻塞不会引发 ANR（Application Not Responding） 呢？</b></u></p>
<p>想象这样一种情况，如果不执行 loop 方法，那么 Android 程序的主线程一运行完程序就会退出！即用户才打开 APP ，APP 就自己关了，这显然是不可以的。<br>那 Android 是怎么实现阻塞而不引发 ANR 呢？</p>
<p>这里需要先了解 ANR 的产生原因：</p>
<ul>
<li>当前的事件没有机会得到处理（即主线程正在处理前一个事件，前一个事件没有及时的完成或者 looper 被某种原因阻塞住了）</li>
<li>当前的事件正在处理，但没能在规定时间内完成（广播事件处理的 10s 限定，输入事件分发 5s ，前台服务 20s 等）</li>
</ul>
<p>由 ANR 产生的原因可以知道一个关键的因素是 —— <strong>没有及时完成</strong>，即在规定时间内没有完成，而主线程 loop 循环这个操作系统并没有对其有时间限定，而 loop 循环内部在处理消息时，对某个具体消息的执行有时是有时间限定的，超过了这个时间就会引发 ANR。</p>
<h5 id="4-3-Looper-的退出方式"><a href="#4-3-Looper-的退出方式" class="headerlink" title="4.3 Looper 的退出方式"></a>4.3 Looper 的退出方式</h5><blockquote>
<p>Looper 也是可以退出的，Looper 提供了 quit 和 quitSafely 来退出一个 Looper</p>
</blockquote>
<ul>
<li>quit 和 quitSafely 方法<br>这两个方法的区别在于： quit 方法会直接退出 Looper，而 quitSafely 只是设定一个退出标记，然后把消息队列中的已有消息处理完成后才安全退出。<br><h5><center>Looper # quit() &amp; quitSafely()</center><br>```java<br>public void quit() {<pre><code>mQueue.quit(false);
</code></pre>  }</h5></li>
</ul>
<p>public void quitSafely() {<br>        mQueue.quit(true);<br>    }</p>
<pre><code>可以看到都调用了 MessageQueue 的 quit 方法。看看 MessageQueue 的 quit 方法
&lt;h5&gt;&lt;center&gt;MessageQueue # quit(boolean safe)&lt;/center&gt;&lt;/h6&gt;
```java
 void quit(boolean safe) {
        if (!mQuitAllowed) {
            throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);
        }

        synchronized (this) {
            if (mQuitting) {
                return;
            }
            mQuitting = true;

            if (safe) {
                removeAllFutureMessagesLocked();
            } else {
                removeAllMessagesLocked();
            }

            // We can assume mPtr != 0 because mQuitting was previously false.
            nativeWake(mPtr);
        }
    }
</code></pre><p>若当前的 MessageQueue 实例属于主线程，那么调用主线程 Looper 的 quit（或 quitSafely）都会抛出这个异常，<code>mQuitAllowed</code>变量在 Looper 的 prepareMainLooper 方法中会被赋值为 false（具体在<code>private static void prepare(boolean quitAllowed)</code>方法中赋值）。</p>
<p>参照 loop 方法可知当 MessageQueue 的 next 方法返回为 null 时，loop 循环就会退出，由此可知，<code>removeAllMessagesLocked</code>方法会直接将下一个待处理消息置为 null，这样 next 方法调用时就会返回 null；<code>removeAllFutureMessagesLocked</code>方法则会在当前消息队列的队尾添加一个 null 消息，并拒绝再接收消息，那么当当前已有的消息处理完就会返回给 next 方法 null，loop 循环就会结束。</p>
<h4 id="5-Handler-的工作原理"><a href="#5-Handler-的工作原理" class="headerlink" title="5 Handler 的工作原理"></a>5 Handler 的工作原理</h4><blockquote>
<p>Handler 的工作主要包括消息的发送和接收。消息的发送可以通过 post 的一系列方法以及 send 的一系列方法来实现，post 的一系列方法最终是通过 send 的一系列方法来实现的。</p>
</blockquote>
<p>send 一系列方法：</p>
<ul>
<li>立即发送消息一条消息：sendMessage</li>
<li>发送空的延迟消息：sendEmptyMessageDelayed</li>
<li>立即发送一条空消息：sendEmptyMessage         </li>
<li>发送一条消息到队列头：sendMessageAtFrontOfQueue </li>
<li>在指定时间发送消息：sendMessageAtTime         </li>
<li>发送延迟消息：sendMessageDelayed        </li>
<li>在指定时间发送空消息：sendEmptyMessageAtTime   </li>
</ul>
<p>post 一系列方法：发送 Runnable 对象，内部调用的是 send 的一系列方法</p>
<ul>
<li>post </li>
<li>postDelayed  </li>
<li>postAtFrontOfQueue   </li>
<li>postAtTime</li>
<li>sendMessageAtTime </li>
</ul>
<p>send 和 post 的一系列方法最终的函数调用（真正进行消息发送操作）为 <code>sendMessageAtTime</code>，或是<code>sendMessageAtFrontOfQueue</code>方法，其他的 sendXXX 和 postXXX 方法最后都会转到这两个方法，对这两个方法进行分析如下</p>
<h5 id="5-1-sendMessageAtTime-方法"><a href="#5-1-sendMessageAtTime-方法" class="headerlink" title="5.1 sendMessageAtTime 方法"></a>5.1 sendMessageAtTime 方法</h5><p>send 的一系列方法中 sendMessage、sendEmptyMessageDelayed、sendEmptyMessage、sendMessageDelayed、sendEmptyMessageAtTime 方法；post 的一系列方法 post、postDelayed、postAtTime 方法的最终调用都为 sendMessageAtTime 方法。</p>
<p></p><h5><center>Handler # sendMessageAtTime(Message msg, long uptimeMillis) </center><p></p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>{
        MessageQueue queue = mQueue;
        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) {
            RuntimeException e = <span class="keyword">new</span> RuntimeException(
                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);
            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);
    }
</code></pre>
<p>方法的第二个参数<code>uptimeMillis</code>文档中解释为：传递该消息的绝对时间，该时间将以 SystemClock.uptimeMillis（开机的到现在的毫秒数，不包括系统睡眠时间）的值作为基数。</p>
<p><code>sendMessageDelayed</code>或<code>sendMessageDelayed</code>方法内部会调用<code>sendMessageAtTime</code>方法，调用形式大都是这样的：<code>sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis)</code>,延迟时间（delayMillis）加上开机到现在的毫秒数即为发送该条消息的绝对时间，<code>sendMessage</code>方法中会调用<code>sendMessageDelayed</code>方法，此时传入的<code>delayMillis</code>就为 0 。</p>
<p>可以看到该方法内部首先会检查 mQueue 是否为 null，为 null 就表示当前线程没有 MessageQueue 对象，为什么没有 MessageQueue 对象，问问自己，MessageQueue 的实例应该在哪里实例化? 在Looper 的构造函数里，那 Looper 的构造函数又在哪里调用呢？ 在 Looper.prepare() …….，对了，很多时候程序抛出该异常就是因为你忘了调用 Looper.prepare() 方法。 </p>
<p>接下来调用 enqueueMessage 方法，看名字就可以猜出来其内部肯定会调用 MessageQueue 的 enqueueMessage 方法将消息插入到消息队列中。</p>
<p></p><h5><center>Handler # enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) </center><p></p>
<pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>{
        msg.target = <span class="keyword">this</span>;
        <span class="keyword">if</span> (mAsynchronous) {
            msg.setAsynchronous(<span class="keyword">true</span>);
        }
        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);
    }
</code></pre>
<h5 id="5-2-sendMessageAtFrontOfQueue-方法"><a href="#5-2-sendMessageAtFrontOfQueue-方法" class="headerlink" title="5.2 sendMessageAtFrontOfQueue 方法"></a>5.2 sendMessageAtFrontOfQueue 方法</h5><p>send 一系列方法的 sendMessageAtFrontOfQueue；post 一系列方法的 postAtFrontOfQueue 方法的最终调用为  sendMessageAtFrontOfQueue 方法。</p>
<p></p><h5><center>Handler # sendMessageAtFrontOfQueue(Message msg) </center><p></p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtFrontOfQueue</span><span class="params">(Message msg)</span> </span>{
    MessageQueue queue = mQueue;
    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) {
        RuntimeException e = <span class="keyword">new</span> RuntimeException(
            <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);
        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
    <span class="keyword">return</span> enqueueMessage(queue, msg, <span class="number">0</span>);
}
</code></pre>
<p>该方法同样会检查 mQueue 是否为 null。<br>注意这里调用<code>enqueueMessage</code>方法时传入的 <code>uptimeMillis</code> 的值为 0 ，你可以往上翻翻，找到 MessageQueue 的 <code>enqueueMessage(Message msg, long when)</code>方法的分析，此时传到 MessageQueue 的 enqueueMessage 方法里的     <code>when</code>的值就为 0 ，通过<code>MessageQueue#enqueueMessage</code>方法就可以知道，当 <code>when == 0</code>，该条消息将被插入消息队列的队头位置。</p>
<h5 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结"></a>5.3 总结</h5><blockquote>
<p>可以发现 Handler 发送消息的过程仅仅是向消息队列中插入一条消息，MessageQueue 的 next 方法就会返回 这条消息给 Looper，Looper 收到消息后开始处理，最终消息由 Handler 处理，即 Handler 的 dispatchMessage 方法会被调用，这时 Handler 就进入处理消息的阶段。 </p>
</blockquote>
<h5 id="5-4-Handler-的-dispatchMessage-方法"><a href="#5-4-Handler-的-dispatchMessage-方法" class="headerlink" title="5.4 Handler 的 dispatchMessage 方法"></a>5.4 Handler 的 dispatchMessage 方法</h5><blockquote>
<p>dispatchMessage 方法会检查消息（Message）的 callback 是否为 null，不为 null 就 通过 handleCallback 来处理消息，实际上就是 Handler 的一系列 post 方法传过来的 Runable 参数。</p>
</blockquote>
<p> </p><h5><center>Handler # dispatchMessage(Message msg) </center><p></p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>{
    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) {
        handleCallback(msg);
    } <span class="keyword">else</span> {
        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) {
            <span class="keyword">if</span> (mCallback.handleMessage(msg)) {
                <span class="keyword">return</span>;
            }
        }
        handleMessage(msg);
    }
}
</code></pre>
<p>dispatchMessage 方法先会检查消息的 callback 是否为 null，其次检查 Handler 的 mCallback 是否为 null，不为 null 则调用其 handleMessage 方法，若该方法返回 true 则消息处理完成，否则（最后）调用 Handler 对象的 handleMessage 方法处理消息。</p>
<p>这里有个小技巧，Handler 的 mCallback 域，通常我们使用 Handler 的方法是使用其导出来（子类），或者是匿名内部类（实质也是子类），这是我们就需要覆写 Handler 的 handleMessage 方法。那如果不想通过继承的方式使用 Handler 呢，mCallback 就是一种途径：<br>Handler 提供了一个构造函数<code>public Handler(Callback callback)</code>，这就允许我们通过传参的方式使用 Handler。</p>
<p>上面提到的几个变量，Message 的 callback，Handler 的 mCallback，callback 是 Runnable 对象，mCallback 为 Handler 的内部类。</p>
<p> </p><h5><center>Handler # Callback  </center><p></p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>{
        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;
    }
</code></pre>
<hr>
<p>文章部分内容摘抄自《Android 开发艺术探索》第 10 章 —— Android 的消息机制，加上大部分自己的理解和总结，可能有错误，欢迎指正。</p>
<center><b><u><em>END</em></u><ub></ub></b></center>

</h5></h5></h5></h5></h5></h5></h5></h5></h5></h5></h5></h5>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/18/android-Activity 的启动模式和标记位/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="James Duan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Duan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/18/android-Activity 的启动模式和标记位/" itemprop="url">Unbenannt</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-18T18:29:48+08:00">
                2017-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>title: Activity 的启动模式和标记位</p>
<h2 id="date-2017-04-14-13-47-11"><a href="#date-2017-04-14-13-47-11" class="headerlink" title="date: 2017-04-14 13:47:11"></a>date: 2017-04-14 13:47:11</h2><h3 id="android-Activity-的启动模式和标记位"><a href="#android-Activity-的启动模式和标记位" class="headerlink" title="android-Activity 的启动模式和标记位"></a>android-Activity 的启动模式和标记位</h3><h5 id="Activity-启动过程涉及到的几个概念"><a href="#Activity-启动过程涉及到的几个概念" class="headerlink" title="Activity 启动过程涉及到的几个概念"></a>Activity 启动过程涉及到的几个概念</h5><blockquote>
<p>任务栈：</p>
</blockquote>
<p>任务栈又称 Task，顾名思义使用的是 <strong>栈</strong> 结构，具有先进后出的特点，栈中存放的是 Activity 组件的实例，我们每次启动一个 Activity （该 Activity 的 onCreate 方法将首次被调用），该 Activity 将被压入启动它的 Activity 所在的任务栈，或通过 Intent 指定<code>addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)</code>在新的任务栈中创建该 Activity。任务栈有前台和后台之分，后台任务栈中的 Activity 处于暂停状态，用户可以通过切换应用（<em>Activity</em>）将后台任务栈调到前台。</p>
<p>####Activity 的 LaunchMode</p>
<ol>
<li>standard 标准模式：<br>标准模式为系统默认启动模式。在该模式下每次启动 Activity 都会重新创建一个新的实例，不管这个实例是否已经存在。在这种模式下，谁启动了这个 Activity ，那么这个 Activity 就运行在启动它的那个 Activity 所在的任务栈中。</li>
<li>singleTop 栈顶复用模式：</li>
</ol>
<ul>
<li>在这种模式下，如果新 Activity 已经位于任务栈的栈顶，那么此 Activity 不会被重新创建    。</li>
<li>如果新 Activity 的实例已存在但不位于栈顶，那么新的 Activity 任会重新。</li>
<li>onNewIntent 方法会被回调。</li>
</ul>
<ol>
<li>singleTask 栈内复用模式：<br>在这种模式下，只要 Activity 在一个栈中存在，那么多次启动该 Activity 都不会重新创建实例，同时系统会回调其 onNewIntent 方法。可以分为如下三种情况进行区分：<ul>
<li>要启动的 Activity A 所需的任务栈 S 不存在：<br>系统先创建任务栈 S ，然后创建 A 并入栈到 S。</li>
<li>要启动的 Activity A 所需的任务栈 S 存在，且任务栈 S 中不存在 A 的实例：<br>系统将创建 A 的实例并入栈到 S。</li>
<li>要启动的 Activity A 所需的任务栈 S 存在，且任务栈 S 中存在 A 的实例 ：<ol>
<li>实例 A 位于栈顶：<br>直接复用（<em>栈顶复用</em>） </li>
<li>实例 A 不位于栈顶：<br>此时 A 不会重新创建，同时将实例 A 切换到栈顶（<em>使实例 A 上面的所有 Activity 出栈</em>）     </li>
</ol>
</li>
</ul>
</li>
<li>singleInstance 单实例模式：<br>这是一种加强的 singleTask 模式，它具有 singleTask 的所有特性之外还有一个特性，那就是具有此种启动模式的 Activity 只能单独位于一个任务栈中。 <h4 id="Activity-的-Flags"><a href="#Activity-的-Flags" class="headerlink" title="Activity 的 Flags"></a>Activity 的 Flags</h4>Activity 的 Flags 有很多，标记位的作用有很多，有的标记位可以设定 Activity 的启动模式，有的可以影响 Activity 的运行状态。</li>
</ol>
<ul>
<li>FLAG_ACTIVITY_NEW_TASK<br>指定 Activity 以 singleTask 模式启动</li>
<li>FLAG_ACTIVITY_SINGLE_TOP<br>指定 Activity 以 singleTop 模式启动</li>
<li>FLAG_ACTIVITY_CLEAR_TOP<br>具备此标记为的 Activity 在启动时会将位于同一任务栈的所有位于它上面的 Activity 出栈，这个标记位一般会和 singleTask一起出现，singleTask 启动模式默认就具有此标记位的效果</li>
<li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS<br>具有这个标记的 Activity 不会出现在历史 Activity 列表中。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/18/Android-View-的事件分发机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="James Duan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Duan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/18/Android-View-的事件分发机制/" itemprop="url">Unbenannt</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-18T16:41:21+08:00">
                2017-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>title: Android-View 的事件分发机制</p>
<h2 id="date-2017-04-16-16-47-11"><a href="#date-2017-04-16-16-47-11" class="headerlink" title="date: 2017-04-16 16:47:11"></a>date: 2017-04-16 16:47:11</h2><h4 id="Android-View的事件分发机制"><a href="#Android-View的事件分发机制" class="headerlink" title="Android-View的事件分发机制"></a>Android-View的事件分发机制</h4><ul>
<li>View 的事件由 MotionEvent 类表示，MotionEvent 定义了大量的常量来表示用户的手指（鼠标、手写笔、轨迹球）在屏幕上的各种状态。View 的事件分发机制指的就是 View （ViewGroup、Button等）在复杂的层级关系里对 MotionEvent 事件的分配和处理规则。</li>
<li>事件序列：当一次手指触摸屏幕行为开始，往往后续会连续触发一连串的事件，如：DOWN -&gt; ..MOVE.. -&gt; UP。也可以说从 <em>ACTION_DOWN</em> 开始到  <em>ACTION_UP</em> 事件到达的过程为一次事件序列。<h5 id="一-MotionEvent"><a href="#一-MotionEvent" class="headerlink" title="一. MotionEvent"></a>一. MotionEvent</h5>MotionEvent 类的定义如下：<br><code>public final class MotionEvent extends InputEvent implements Parcelable</code><br>该类继承了 InputEvent （抽象类，输入事件的表示类），同时该类是可序列化的。<h6 id="1-1-常见的事件状态："><a href="#1-1-常见的事件状态：" class="headerlink" title="1.1 常见的事件状态："></a>1.1 常见的事件状态：</h6></li>
<li><code>ACTION_DOWN</code><br>手指刚接触屏幕，按下的手势已经开始，此次事件序列的起始位置（坐标）被赋值。<br>-<code>ACTION_UP</code><br>手指从屏幕松开的一瞬间，按下的手势结束，此次事件序列结束，最终的结束位置（坐标）决定。</li>
<li><code>ACTION_MOVE</code><br>在接收到 ACTION_DOWN 之后，接收到 ACTION_UP 之前，在手指和屏幕保持接触的前提下手指的位置（坐标）发生了改变。<h5 id="1-2-默认的规则"><a href="#1-2-默认的规则" class="headerlink" title="1.2 默认的规则"></a>1.2 默认的规则</h5><a id="rule"></a><blockquote>
<p>规则 1</p>
<blockquote>
<p>ViewGroup 默认不拦截任何事件。Android 源码中 ViewGroup 的 onInterceptTouchEvent 方法默认返回 false</p>
</blockquote>
</blockquote>
</li>
</ul>
<blockquote>
<p>规则 2</p>
<blockquote>
<p>View 的 onTouchEvent 默认都会消耗事件（返回 true） ，除非他是不可点击的（clickable 、 longClickable 和 contextClickable 都为 false）。</p>
</blockquote>
<p>规则 3</p>
<blockquote>
<p>onCLick 会发生的前提是当前 View 是可点击的，并且它收到了 DOWN 和 UP 事件。</p>
<h5 id="二-触摸事件涉及到的主要方法"><a href="#二-触摸事件涉及到的主要方法" class="headerlink" title="二.  触摸事件涉及到的主要方法"></a>二.  触摸事件涉及到的主要方法</h5><ul>
<li><code>public boolean dispatchTouchEvent(MotionEvent event)</code><br>事件分发逻辑处理的主要方法，如果触摸事件传递到当前 View 那么该方法一定会被调用，返回结果受当前 View 的 onTouchEvent 和下级 View 的 dispatchTouchEvent 方法的影响，表示是否消耗掉当前事件。</li>
<li><code>public boolean onInterceptTouchEvent(MotionEvent event)</code><br>在 dispatchTouchEvent 方法中调用，用来判断是否拦截某个事件，如果当前 View 拦截了某个事件，那么在同一个事件序列中该方法不会再调用，返回结果表示是否拦截当前事件。 </li>
<li><code>public boolean onTouchEvent(MotionEvent event)</code><br>在 dispatchTouchEvent 方法中调用，用来处理触摸事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前 View 无法再次接收到事件。<h5 id="三-事件分发过程"><a href="#三-事件分发过程" class="headerlink" title="三. 事件分发过程"></a>三. 事件分发过程</h5><h6 id="3-1-ViewGroup-的-dispatchTouchEvent-方法"><a href="#3-1-ViewGroup-的-dispatchTouchEvent-方法" class="headerlink" title="3.1 ViewGroup 的 dispatchTouchEvent 方法"></a>3.1 ViewGroup 的 dispatchTouchEvent 方法</h6></li>
</ul>
<ol>
<li>对于一个根 ViewGroup 来说，点击事件产生后，首先会传递给它，这时它的<code>dispatchTouchEvent</code>就会被调用：</li>
</ol>
<ul>
<li>如果这个 ViewGroup 的 <code>onInterceptTouchEvent</code>方法返回 true就表示它要拦截当前事件，接着事件就会交给这个 ViewGroup 处理，即它的 <code>onTouchEvent</code>方法就会被调用</li>
<li>如果这个 ViewGroup 的 <code>onInterceptTouchEvent</code> 方法返回 false 就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的 <code>dispatchTouchEvent</code>方法就会被调用，如此反复直到最终事件被处理。</li>
</ul>
<ol>
<li>参照源码加深理解<br>源码 <code>dispatchTouchEvent</code> 方法比较复杂，这里分段从前往后选取关键部分依次进行分析。</li>
</ol>
</blockquote>
</blockquote>
<p>（1）判断当前 View（ViewGroup）是否拦截事件</p>
<pre><code class="java">        -------------ViewGroup#dispatchTouchEvent---------------
 public boolean dispatchTouchEvent(MotionEvent ev) {
 ...
// Check for interception.
            final boolean intercepted;
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
            }
            ...
}
</code></pre>
<p>一句一句进行分析：</p>
<p><center><font size="+2"><strong><code>if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)</code></strong>:</font></center><br>如果当前事件为 <em>ACTION_DOWN</em>，并且<code>mFirstTouchTarget</code>不为空，就进行后面的操作。那么<code>mFirstTouchTarget</code>是什么呢？</p>
<blockquote>
<p>根据 ViewGroup 的 onDispatchTouchEvent 方法后面部分得分析可知，当事件由 <em>ViewGroup</em>的子元素成功处理时（ViewGroup）没有进行拦截，mFirstTouchTarget 将被赋值，并指向其子元素，反过来，如果<em>ViewGroup</em>对事件进行拦截，mFirstTouchTarget != null 就不成立。</p>
</blockquote>
<p>大家可能疑惑这句将<code>mFirstTouchTarget</code>是否为空作为判断条件，而<code>mFirstTouchTarget</code>的赋值却在这个<code>if()</code>判断之后，那<code>mFirstTouchTarget</code>不是一定为 null！<br>    <code>mFirstTouchTarget</code>作为全局变量，当<code>dispatchTouchEvent</code><strong>第一次</strong>被调用时其值一定为空，而<code>actionMasked == MotionEvent.ACTION_DOWN</code>一定为 true ，这时，ViewGroup 的 <code>onInterceptTouchEvent</code>会被调用，如果其返回为 true，表示要拦截（那么 intercepted 为 true，mFirstTouchTarget 将不被赋值为空），那么此次的 <em>ACTION_DOWN</em>事件就被拦截，<em>ACTION_DOWN</em>是一次事件序列的开始，那么当此次事件序列的下一个事件到达调用<code>dispatchTouchEvent</code>方法并运行到<code>if()</code>时，该<code>if()</code>将为 false（此时 <code>actionMasked != MotionEvent.ACTION_DOWN</code>且<code>mFirstTouchTarget  == null</code>），则 <code>intercepted = true</code>，这就得出一个结论：</p>
<blockquote>
<p>结论 1 </p>
<blockquote>
<p>某个 View 一旦决定拦截，那么这一事件序列都只能由它来处理（如果事件序列能够传递给他的话），并且它的 onInterceptTouchEvent 不会再被调用。</p>
</blockquote>
</blockquote>
<p><center><font size="+2"><strong><code>final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;if (!disallowIntercept) {...</code></strong></font></center><br>这句中使用到了一个标记位<code>FLAG_DISALLOW_INTERCEPT</code>，那么这个标记位是否启用是由谁决定、怎么决定的呢？<br>这里我们讨论的是 ViewGroup 的    <code>dispatchTouchEvent</code> 方法，<code>dispatchTouchEvent</code> 方法如果不拦截事件，那么 ViewGroup 就会将事件传递给它的子 View，这时子 View 可以通过其所在容器（父视图 ViewGroup）的引用调用 ViewGroup 的 <code>requestDisallowInterceptTouchEvent(boolean disallowIntercept)</code>方法改变 ViewGroup 的行为（启用或停用<code>FLAG_DISALLOW_INTERCEPT</code>标记位），使 ViewGroup 不再拦截除 ACTION_DOWN 以外的其它事件。</p>
<p>为什么说除了 ACTION_DOWN 以外的事件呢？</p>
<blockquote>
<p>这是因为 ViewGroup 在分发事件时，如果是 ACTION_DOWN 事件就会重置 <code>FLAG_DISALLOW_INTERCEPT</code>标记位，使该标记位失效，即当面对 ACTION_DOWN 事件时，ViewGroup 总会调用自己的 <code>onInterceptTouchEvent</code>方法来询问自己是否要拦截事件。这一点在源码中也有体现：</p>
<pre><code class="java"><span class="comment">// Handle an initial down.</span>
            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) {
                <span class="comment">// Throw away all previous state when starting a new touch gesture.</span>
                <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span>
                <span class="comment">// due to an app switch, ANR, or some other state change.</span>
                cancelAndClearTouchTargets(ev);
                resetTouchState();
            }
</code></pre>
<p>结论 2 </p>
<blockquote>
<p>事件传递是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子元素，通过 requestDisallowInterceptTouchEvent 方法可以在子元素中干预父元素的事件分发过程，但是 ACTION_DOWN 事件除外。</p>
</blockquote>
</blockquote>
<p>（2）ViewGroup 不拦截事件，将事件分发给子 View </p>
<pre><code class="java">       -------------ViewGroup#dispatchTouchEvent---------------
public boolean dispatchTouchEvent(MotionEvent ev) {
...
                        final View[] children = mChildren;
                        for (int i = childrenCount - 1; i &gt;= 0; i--) {
                            final int childIndex = getAndVerifyPreorderedIndex(
                                    childrenCount, i, customOrder);
                            final View child = getAndVerifyPreorderedView(
                                    preorderedList, children, childIndex);

                            // If there is a view that has accessibility focus we want it
                            // to get the event first and if not handled we will perform a
                            // normal dispatch. We may do a double iteration but this is
                            // safer given the timeframe.
                            if (childWithAccessibilityFocus != null) {
                                if (childWithAccessibilityFocus != child) {
                                    continue;
                                }
                                childWithAccessibilityFocus = null;
                                i = childrenCount - 1;
                            }

                            if (!canViewReceivePointerEvents(child)
                                    || !isTransformedTouchPointInView(x, y, child, null)) {
                                ev.setTargetAccessibilityFocus(false);
                                continue;
                            }

                            newTouchTarget = getTouchTarget(child);
                            if (newTouchTarget != null) {
                                // Child is already receiving touch within its bounds.
                                // Give it the new pointer in addition to the ones it is handling.
                                newTouchTarget.pointerIdBits |= idBitsToAssign;
                                break;
                            }

                            resetCancelNextUpFlag(child);
                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                // Child wants to receive touch within its bounds.
                                mLastTouchDownTime = ev.getDownTime();
                                if (preorderedList != null) {
                                    // childIndex points into presorted list, find original index
                                    for (int j = 0; j &lt; childrenCount; j++) {
                                        if (children[childIndex] == mChildren[j]) {
                                            mLastTouchDownIndex = j;
                                            break;
                                        }
                                    }
                                } else {
                                    mLastTouchDownIndex = childIndex;
                                }
                                mLastTouchDownX = ev.getX();
                                mLastTouchDownY = ev.getY();
                                newTouchTarget = addTouchTarget(child, idBitsToAssign);
                                alreadyDispatchedToNewTouchTarget = true;
                                break;
                            }
                   ...
}
</code></pre>
<p><center><font size="+2"><code>for (int i = childrenCount - 1; i &gt;= 0; i--) {...</code></font><br></center><br>将事件分发给子 View 的过程通过遍历每一个子 View，判断子 View是否能接收到事件，能就调用其 <code>dispatchTouchEvent</code>方法，若子 View 的 <code>dispatchTouchEvent</code>方法返回 false ，表示子 View 未消耗事件，则继续循环；如果子 View 的 <code>dispatchTouchEvent</code>方法返回 true，表示子 View 消耗了事件，那么<code>mFirstTouchTarget</code>将被赋值，同时结束循环。</p>
<ul>
<li>如何判断子 View 是否能接收到事件：<br>子元素是否在播放动画<br>点击事件的坐标是否落在子元素的区域内<pre><code>...
if (childWithAccessibilityFocus != null) {
  ...
}
if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
  ...
}
...
</code></pre></li>
<li><code>mFirstTouchTarget</code>的赋值：对应代码为：<pre><code class="java">newTouchTarget = addTouchTarget(child, idBitsToAssign);
alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;
<span class="keyword">break</span>;
</code></pre>
具体的赋值在<code>addTouchTarget</code>方法内部。</li>
<li>遍历所有子元素都没有被处理：这包含两种情况，第一种为 ViewGroup 没有子元素，第二种是子元素处理了点击事件，但 子元素的 <code>dispatchTouchEvent</code>方法返回了false（这一般是因为子元素在<code>onTouchEvent</code>方法中返回了false），此时 ViewGroup 将自己处理事件。<br>结论：<br><a id="result3"></a><blockquote>
<p>结论 3 </p>
<blockquote>
<p>某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN 事件（onTouchEvent返回false），那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将重新交由它的父元素去处理，即父元素的 onTouchEvent 会被调用。意思就是事件一旦交给一个 View 来处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不再交给它来处理。</p>
</blockquote>
</blockquote>
</li>
</ul>
<p> 这个结论可以结合代码来理解：<br><strong><code>某个 View 一旦开始处理事件</code></strong>：在开始循环前各个关键变量的值应该是这样的：<br>1.<code>mFirstTouchTarget</code>一定为空<br>2.<code>intercepted</code>一定为 false<br>3.可以推出<code>actionMasked == MOtionEvent.ACTION_DOWN</code>（这里参照 3.1 的部分）。</p>
<p> 之后遍历子 View 开始，在确定了<strong>某一个</strong>子 View <em>CV</em> 能接收到事件后，调用<em>CV</em>的<code>dispatchTouchEvent</code>方法（<code>dispatchTransformedTouchEvent</code>方法内部）：</p>
<ul>
<li>若<code>dispatchTouchEvent</code>返回 true ，表示<em>CV</em>消耗了<strong>ACTION_DOWN</strong>事件，这时对<code>mFirstTouchTarget</code>赋值，使其指向<em>CV</em>，并跳出循环。当此次事件序列的下一个事件到达，假设为 ACTION_MOVE，此时<code>mFirstTouchTarget != null</code>成立，如果<em>CV</em>调用了<code>requestDisallowInterceptTouchEvent</code>方法启用<code>FLAG_DISALLOW_INTERCEPT</code>标记位（<code>disallowIntercept 为 true</code>），则 <code>intercepted</code>为 false，若<code>FLAG_DISALLOW_INTERCEPT</code>标记位没有被启用，那么 ViewGroup 的 <code>onInterceptTouchEvent</code>再次调用，参考 <a href="#rule">规则 1 </a>可以知道，一般情况下<code>intercepted</code>也会为 false，那么 <strong>同一事件序列中的其他事件都会交给它处理</strong>。</li>
<li>若<code>dispatchTouchEvent</code>返回 false，即 <em>CV</em> 不消耗 ACTION_DOWN 事件（onTouchEvent返回false）,此时会继续往下遍历子 View，如果遍历结束都没有被处理，那么 ViewGroup 将自己处理该事件，即<strong>父元素的 onTouchEvent 会被调用</strong>。</li>
</ul>
<h6 id="3-2-View-的-dispatchTouchEvent-方法"><a href="#3-2-View-的-dispatchTouchEvent-方法" class="headerlink" title="3.2 View 的 dispatchTouchEvent 方法"></a>3.2 View 的 dispatchTouchEvent 方法</h6><p>View 的<code>dispatchTouchEvent</code>方法要简单一些，这里的 View 不包括 ViewGroup 。</p>
<blockquote>
<p>View（不包括 ViewGroup）做为一个单独的元素，它没有子元素无法向下传递事件，所以只能自己处理事件。</p>
</blockquote>
<p>（一） 事件传递到了某一个具体的 View 那就表明该 View 能接收到触摸事件，传递过来的第一个事件一定是此次事件序列的 <code>ACTION_DOWN</code> 事件，如果 View 消耗了 <code>ACTION_DOWN</code> 事件（返回true），那么该事件序列的后续事件都会传递给他，如果没消耗 <code>ACTION_DOWN</code> ，那么它将无法收到后续事件。参考  <a href="#result3">结论 3 </a></p>
<p>如果 View 只想处理 <code>ACTION_DOWN</code> 事件，而不处理其他事件，那可以覆写 <code>dispatchTouchEvent</code>方法或通过设置监听器实现（<code>setOnTouchListener(OnTouchListener l)</code>），在方法中加入如下判断即可：</p>
<pre><code class="java">...
<span class="keyword">if</span>(event.getAction() == MotionEvent.ACTION_DOWN)
    <span class="keyword">return</span> <span class="keyword">false</span>;
...
</code></pre>
<p>（二） 内部监听和外部监听 </p>
<pre><code class="java">-------------View#dispatchTouchEvent---------------
 public boolean dispatchTouchEvent(MotionEvent event) {
...
        if (onFilterTouchEventForSecurity(event)) {
            if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) {
                result = true;
            }
            //noinspection SimplifiableIfStatement
            ListenerInfo li = mListenerInfo;
            if (li != null &amp;&amp; li.mOnTouchListener != null
                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                    &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
                result = true;
            }

            if (!result &amp;&amp; onTouchEvent(event)) {
                result = true;
            }
        }

...
        return result;
    }
</code></pre>
<blockquote>
<p>从源码可以看出，首先会判断有没有设置 OnTouchListener ，如果有，并且 OnTouchListener 中的 onTouch 方法返回 true，那么 onTouchEvent 就不会被调用，可见 OnTouchListener 的优先级高于 OnTouchEvent，这样做的好处是方便在外界处理触摸事件。</p>
</blockquote>
<p>所以如果想屏蔽 View 默认的触摸事件处理只需为 View 设置监听器并返回 true 即可。</p>
<pre><code class="java">view.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() {
      <span class="meta">@Override</span>
      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>{
          <span class="keyword">return</span> <span class="keyword">true</span>;
      }
 });
</code></pre>
<p>（三）View 的 onTouchEvent 对 DISEABLED 的处理</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>{
    ...
     <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) {
         <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) {
             setPressed(<span class="keyword">false</span>);
         }
         <span class="comment">// A disabled view that is clickable still consumes the touch</span>
         <span class="comment">// events, it just doesn't respond to them.</span>
         <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE
                 || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)
                 || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);
     }
   ...
     <span class="keyword">return</span> <span class="keyword">false</span>;
 }
</code></pre>
<blockquote>
<p>从源码可看出，当 View 处于不可用状态时，只要 CLICKABLE ，LONG_CLICKABLE 和 CONTEXT_CLICKABLE  有一者为 true，onTouchEvent 就会返回 true，即消耗事件。</p>
</blockquote>
<p>这里有个<code>CONTEXT_CLICKABLE</code>，这个常量指的又是什么呢？<br><code>CONTEXT_CLICKABLE</code>是 Android SDK 23 （Android 6.0）加入的，表示触控笔上下文单击（触控笔按钮）和鼠标右键单击是否可用。为其设置监听器时应使用 onContextClick 代替 onStylusButtonPress。</p>
<p>（四）View 的 onTouchEvent 对点击事件的实现</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>{
    ...
      <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||
             (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||
             (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {
       <span class="keyword">switch</span> (action) {
       <span class="keyword">case</span> MotionEvent.ACTION_UP:
        ...
                         <span class="keyword">if</span> (!focusTaken) {
                             <span class="comment">// Use a Runnable and post this rather than calling</span>
                             <span class="comment">// performClick directly. This lets other visual state</span>
                             <span class="comment">// of the view update before click actions start.</span>
                             <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) {
                                 mPerformClick = <span class="keyword">new</span> PerformClick();
                             }
                             <span class="keyword">if</span> (!post(mPerformClick)) {
                                 performClick();
                             }
                         }
                        }
   ...
     <span class="keyword">return</span> <span class="keyword">false</span>;
 }
</code></pre>
<blockquote>
<p>当 ACTION_UP 事件到达时，会触发 performClick 方法，如果 View 设置了 OnClickListener，那么 performClick 内部会调用它的 onClick 方法。 </p>
</blockquote>
<p>注释中说明了要使用 post 方法通过 Handler 执行 onClick，这让我们能够在 onClick 执行之前看到 View 的状态更新。</p>
<p>（五）CLICKABLE ，LONG_CLICKABLE 和 CONTEXT_CLICKABLE  的设置</p>
<blockquote>
<p>View 的 LONG_CLICKABLE 属性默认为 false ，而 CLICKABLE 属性是否为 false 和具体的 View 相关，确切来说是可点击的 View 的 CLICKABLE 为 true ，不可点击的 View 的 CLICKABLE 为 false，比如 Button 是可点击的，而 TextView 是不可点击 的。通过 setClickable 、 setLongClickable 和 setContextClickable 可修改三者的值。另外，setOnClickListener、setOnLongClickListener 和 setOnContextClickListener 方法内部会自动将 View 的对应属性的 XXXable 值改为 true。</p>
</blockquote>
<p>文章大部分摘抄自《Android 开发艺术探索》，第三章 3.4 节 —— View的事件分发机制，加上部分自己的理解，可能有错误，欢迎指正。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="James Duan" />
          <p class="site-author-name" itemprop="name">James Duan</p>
           
              <p class="site-description motion-element" itemprop="description">just do it.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/DuanJiaNing" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/aimeimeits" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-csdn"></i>
                  
                  CSDN
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="aimeimeits@gmail.com" target="_blank" title="Gmail">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Gmail
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CAFE_BABE_Duan" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="2217611834" target="_blank" title="QQ">
                  
                    <i class="fa fa-fw fa-qq"></i>
                  
                  QQ
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  Thu May 18 2017 08:00:00 GMT+0800 (中国标准时间) - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">James Duan</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
