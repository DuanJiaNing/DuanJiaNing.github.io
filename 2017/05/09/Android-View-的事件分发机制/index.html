<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android,MotionEvent,触摸事件分发," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Android-View的事件分发机制 View 的事件由 MotionEvent 类表示，MotionEvent 定义了大量的常量来表示用户的手指（鼠标、手写笔、轨迹球）在屏幕上的各种状态。View 的事件分发机制指的就是 View （ViewGroup、Button等）在复杂的层级关系里对 MotionEvent 事件的分配和处理规则。 事件序列：当一次手指触摸屏幕行为开始，往往后续会连续触发">
<meta name="keywords" content="Android,MotionEvent,触摸事件分发">
<meta property="og:type" content="article">
<meta property="og:title" content="Android：View 的事件分发机制">
<meta property="og:url" content="http://yoursite.com/2017/05/09/Android-View-的事件分发机制/index.html">
<meta property="og:site_name" content="Duan">
<meta property="og:description" content="Android-View的事件分发机制 View 的事件由 MotionEvent 类表示，MotionEvent 定义了大量的常量来表示用户的手指（鼠标、手写笔、轨迹球）在屏幕上的各种状态。View 的事件分发机制指的就是 View （ViewGroup、Button等）在复杂的层级关系里对 MotionEvent 事件的分配和处理规则。 事件序列：当一次手指触摸屏幕行为开始，往往后续会连续触发">
<meta property="og:updated_time" content="2017-05-18T12:47:32.604Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android：View 的事件分发机制">
<meta name="twitter:description" content="Android-View的事件分发机制 View 的事件由 MotionEvent 类表示，MotionEvent 定义了大量的常量来表示用户的手指（鼠标、手写笔、轨迹球）在屏幕上的各种状态。View 的事件分发机制指的就是 View （ViewGroup、Button等）在复杂的层级关系里对 MotionEvent 事件的分配和处理规则。 事件序列：当一次手指触摸屏幕行为开始，往往后续会连续触发">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/05/09/Android-View-的事件分发机制/"/>





  <title>Android：View 的事件分发机制 | Duan</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Duan</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The more hard, the more fortunate.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/09/Android-View-的事件分发机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="James Duan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Duan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android：View 的事件分发机制</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-09T22:33:29+08:00">
                2017-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="Android-View的事件分发机制"><a href="#Android-View的事件分发机制" class="headerlink" title="Android-View的事件分发机制"></a>Android-View的事件分发机制</h4><ul>
<li>View 的事件由 MotionEvent 类表示，MotionEvent 定义了大量的常量来表示用户的手指（鼠标、手写笔、轨迹球）在屏幕上的各种状态。View 的事件分发机制指的就是 View （ViewGroup、Button等）在复杂的层级关系里对 MotionEvent 事件的分配和处理规则。</li>
<li>事件序列：当一次手指触摸屏幕行为开始，往往后续会连续触发一连串的事件，如：DOWN -&gt; ..MOVE.. -&gt; UP。也可以说从 <em>ACTION_DOWN</em> 开始到  <em>ACTION_UP</em> 事件到达的过程为一次事件序列。</li>
</ul>
<h5 id="一-MotionEvent"><a href="#一-MotionEvent" class="headerlink" title="一. MotionEvent"></a>一. MotionEvent</h5><p>MotionEvent 类的定义如下：<br><code>public final class MotionEvent extends InputEvent implements Parcelable</code><br>该类继承了 InputEvent （抽象类，输入事件的表示类），同时该类是可序列化的。</p>
<h6 id="1-1-常见的事件状态："><a href="#1-1-常见的事件状态：" class="headerlink" title="1.1 常见的事件状态："></a>1.1 常见的事件状态：</h6><ul>
<li><code>ACTION_DOWN</code><br>手指刚接触屏幕，按下的手势已经开始，此次事件序列的起始位置（坐标）被赋值。<br>-<code>ACTION_UP</code><br>手指从屏幕松开的一瞬间，按下的手势结束，此次事件序列结束，最终的结束位置（坐标）决定。</li>
<li><code>ACTION_MOVE</code><br>在接收到 ACTION_DOWN 之后，接收到 ACTION_UP 之前，在手指和屏幕保持接触的前提下手指的位置（坐标）发生了改变。</li>
</ul>
<h5 id="1-2-默认的规则"><a href="#1-2-默认的规则" class="headerlink" title="1.2 默认的规则"></a>1.2 默认的规则</h5><p><a id="rule"></a></p>
<blockquote>
<p>规则 1</p>
<blockquote>
<p>ViewGroup 默认不拦截任何事件。Android 源码中 ViewGroup 的 onInterceptTouchEvent 方法默认返回 false</p>
</blockquote>
<p>规则 2</p>
<blockquote>
<p>View 的 onTouchEvent 默认都会消耗事件（返回 true） ，除非他是不可点击的（clickable 、 longClickable 和 contextClickable 都为 false）。</p>
</blockquote>
<p>规则 3</p>
<blockquote>
<p>onCLick 会发生的前提是当前 View 是可点击的，并且它收到了 DOWN 和 UP 事件。</p>
</blockquote>
</blockquote>
<h5 id="二-触摸事件涉及到的主要方法"><a href="#二-触摸事件涉及到的主要方法" class="headerlink" title="二.  触摸事件涉及到的主要方法"></a>二.  触摸事件涉及到的主要方法</h5><ul>
<li><code>public boolean dispatchTouchEvent(MotionEvent event)</code><br>事件分发逻辑处理的主要方法，如果触摸事件传递到当前 View 那么该方法一定会被调用，返回结果受当前 View 的 onTouchEvent 和下级 View 的 dispatchTouchEvent 方法的影响，表示是否消耗掉当前事件。</li>
<li><code>public boolean onInterceptTouchEvent(MotionEvent event)</code><br>在 dispatchTouchEvent 方法中调用，用来判断是否拦截某个事件，如果当前 View 拦截了某个事件，那么在同一个事件序列中该方法不会再调用，返回结果表示是否拦截当前事件。 </li>
<li><code>public boolean onTouchEvent(MotionEvent event)</code><br>在 dispatchTouchEvent 方法中调用，用来处理触摸事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前 View 无法再次接收到事件。</li>
</ul>
<h5 id="三-事件分发过程"><a href="#三-事件分发过程" class="headerlink" title="三. 事件分发过程"></a>三. 事件分发过程</h5><h6 id="3-1-ViewGroup-的-dispatchTouchEvent-方法"><a href="#3-1-ViewGroup-的-dispatchTouchEvent-方法" class="headerlink" title="3.1 ViewGroup 的 dispatchTouchEvent 方法"></a>3.1 ViewGroup 的 dispatchTouchEvent 方法</h6><ol>
<li>对于一个根 ViewGroup 来说，点击事件产生后，首先会传递给它，这时它的<code>dispatchTouchEvent</code>就会被调用：</li>
</ol>
<ul>
<li>如果这个 ViewGroup 的 <code>onInterceptTouchEvent</code>方法返回 true就表示它要拦截当前事件，接着事件就会交给这个 ViewGroup 处理，即它的 <code>onTouchEvent</code>方法就会被调用</li>
<li>如果这个 ViewGroup 的 <code>onInterceptTouchEvent</code> 方法返回 false 就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的 <code>dispatchTouchEvent</code>方法就会被调用，如此反复直到最终事件被处理。</li>
</ul>
<ol>
<li>参照源码加深理解<br>源码 <code>dispatchTouchEvent</code> 方法比较复杂，这里分段从前往后选取关键部分依次进行分析。</li>
</ol>
<p>（1）判断当前 View（ViewGroup）是否拦截事件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">		-------------ViewGroup#dispatchTouchEvent---------------</div><div class="line"> public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class="line"> ...</div><div class="line">// Check for interception.</div><div class="line">            final boolean intercepted;</div><div class="line">            if (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                    || mFirstTouchTarget != null) &#123;</div><div class="line">                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</div><div class="line">                if (!disallowIntercept) &#123;</div><div class="line">                    intercepted = onInterceptTouchEvent(ev);</div><div class="line">                    ev.setAction(action); // restore action in case it was changed</div><div class="line">                &#125; else &#123;</div><div class="line">                    intercepted = false;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                // There are no touch targets and this action is not an initial down</div><div class="line">                // so this view group continues to intercept touches.</div><div class="line">                intercepted = true;</div><div class="line">            &#125;</div><div class="line">            ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一句一句进行分析：</p>
<center><font size="+2"><strong><code>if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)</code></strong>:</font></center><br>如果当前事件为 <em>ACTION_DOWN</em>，并且<code>mFirstTouchTarget</code>不为空，就进行后面的操作。那么<code>mFirstTouchTarget</code>是什么呢？<br>&gt;根据 ViewGroup 的 onDispatchTouchEvent 方法后面部分得分析可知，当事件由 <em>ViewGroup</em>的子元素成功处理时（ViewGroup）没有进行拦截，mFirstTouchTarget 将被赋值，并指向其子元素，反过来，如果<em>ViewGroup</em>对事件进行拦截，mFirstTouchTarget != null 就不成立。<br><br>大家可能疑惑这句将<code>mFirstTouchTarget</code>是否为空作为判断条件，而<code>mFirstTouchTarget</code>的赋值却在这个<code>if()</code>判断之后，那<code>mFirstTouchTarget</code>不是一定为 null！<br>    <code>mFirstTouchTarget</code>作为全局变量，当<code>dispatchTouchEvent</code><strong>第一次</strong>被调用时其值一定为空，而<code>actionMasked == MotionEvent.ACTION_DOWN</code>一定为 true ，这时，ViewGroup 的 <code>onInterceptTouchEvent</code>会被调用，如果其返回为 true，表示要拦截（那么 intercepted 为 true，mFirstTouchTarget 将不被赋值为空），那么此次的 <em>ACTION_DOWN</em>事件就被拦截，<em>ACTION_DOWN</em>是一次事件序列的开始，那么当此次事件序列的下一个事件到达调用<code>dispatchTouchEvent</code>方法并运行到<code>if()</code>时，该<code>if()</code>将为 false（此时 <code>actionMasked != MotionEvent.ACTION_DOWN</code>且<code>mFirstTouchTarget  == null</code>），则 <code>intercepted = true</code>，这就得出一个结论：<br>&gt;结论 1<br>&gt;&gt;某个 View 一旦决定拦截，那么这一事件序列都只能由它来处理（如果事件序列能够传递给他的话），并且它的 onInterceptTouchEvent 不会再被调用。<br><br><center><font size="+2"><strong><code>final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;if (!disallowIntercept) {...</code></strong></font></center><br>这句中使用到了一个标记位<code>FLAG_DISALLOW_INTERCEPT</code>，那么这个标记位是否启用是由谁决定、怎么决定的呢？<br>这里我们讨论的是 ViewGroup 的    <code>dispatchTouchEvent</code> 方法，<code>dispatchTouchEvent</code> 方法如果不拦截事件，那么 ViewGroup 就会将事件传递给它的子 View，这时子 View 可以通过其所在容器（父视图 ViewGroup）的引用调用 ViewGroup 的 <code>requestDisallowInterceptTouchEvent(boolean disallowIntercept)</code>方法改变 ViewGroup 的行为（启用或停用<code>FLAG_DISALLOW_INTERCEPT</code>标记位），使 ViewGroup 不再拦截除 ACTION_DOWN 以外的其它事件。<br><br>为什么说除了 ACTION_DOWN 以外的事件呢？<br>&gt;这是因为 ViewGroup 在分发事件时，如果是 ACTION_DOWN 事件就会重置 <code>FLAG_DISALLOW_INTERCEPT</code>标记位，使该标记位失效，即当面对 ACTION_DOWN 事件时，ViewGroup 总会调用自己的 <code>onInterceptTouchEvent</code>方法来询问自己是否要拦截事件。这一点在源码中也有体现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Handle an initial down.</span></div><div class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">                <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></div><div class="line">                <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></div><div class="line">                <span class="comment">// due to an app switch, ANR, or some other state change.</span></div><div class="line">                cancelAndClearTouchTargets(ev);</div><div class="line">                resetTouchState();</div><div class="line">            &#125;</div></pre></td></tr></table></figure><br><br>&gt;结论 2<br>&gt;&gt;事件传递是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子元素，通过 requestDisallowInterceptTouchEvent 方法可以在子元素中干预父元素的事件分发过程，但是 ACTION_DOWN 事件除外。<br><br>（2）ViewGroup 不拦截事件，将事件分发给子 View<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">       -------------ViewGroup#dispatchTouchEvent---------------</div><div class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class="line">...</div><div class="line">						final View[] children = mChildren;</div><div class="line">                        for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</div><div class="line">                            final int childIndex = getAndVerifyPreorderedIndex(</div><div class="line">                                    childrenCount, i, customOrder);</div><div class="line">                            final View child = getAndVerifyPreorderedView(</div><div class="line">                                    preorderedList, children, childIndex);</div><div class="line"></div><div class="line">                            // If there is a view that has accessibility focus we want it</div><div class="line">                            // to get the event first and if not handled we will perform a</div><div class="line">                            // normal dispatch. We may do a double iteration but this is</div><div class="line">                            // safer given the timeframe.</div><div class="line">                            if (childWithAccessibilityFocus != null) &#123;</div><div class="line">                                if (childWithAccessibilityFocus != child) &#123;</div><div class="line">                                    continue;</div><div class="line">                                &#125;</div><div class="line">                                childWithAccessibilityFocus = null;</div><div class="line">                                i = childrenCount - 1;</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            if (!canViewReceivePointerEvents(child)</div><div class="line">                                    || !isTransformedTouchPointInView(x, y, child, null)) &#123;</div><div class="line">                                ev.setTargetAccessibilityFocus(false);</div><div class="line">                                continue;</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            newTouchTarget = getTouchTarget(child);</div><div class="line">                            if (newTouchTarget != null) &#123;</div><div class="line">                                // Child is already receiving touch within its bounds.</div><div class="line">                                // Give it the new pointer in addition to the ones it is handling.</div><div class="line">                                newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                                break;</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            resetCancelNextUpFlag(child);</div><div class="line">                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</div><div class="line">                                // Child wants to receive touch within its bounds.</div><div class="line">                                mLastTouchDownTime = ev.getDownTime();</div><div class="line">                                if (preorderedList != null) &#123;</div><div class="line">                                    // childIndex points into presorted list, find original index</div><div class="line">                                    for (int j = 0; j &lt; childrenCount; j++) &#123;</div><div class="line">                                        if (children[childIndex] == mChildren[j]) &#123;</div><div class="line">                                            mLastTouchDownIndex = j;</div><div class="line">                                            break;</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;</div><div class="line">                                &#125; else &#123;</div><div class="line">                                    mLastTouchDownIndex = childIndex;</div><div class="line">                                &#125;</div><div class="line">                                mLastTouchDownX = ev.getX();</div><div class="line">                                mLastTouchDownY = ev.getY();</div><div class="line">                                newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">                                alreadyDispatchedToNewTouchTarget = true;</div><div class="line">                                break;</div><div class="line">                            &#125;</div><div class="line">                   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br><center><font size="+2"><code>for (int i = childrenCount - 1; i &gt;= 0; i--) {...</code></font><br></center><br>将事件分发给子 View 的过程通过遍历每一个子 View，判断子 View是否能接收到事件，能就调用其 <code>dispatchTouchEvent</code>方法，若子 View 的 <code>dispatchTouchEvent</code>方法返回 false ，表示子 View 未消耗事件，则继续循环；如果子 View 的 <code>dispatchTouchEvent</code>方法返回 true，表示子 View 消耗了事件，那么<code>mFirstTouchTarget</code>将被赋值，同时结束循环。<br>- 如何判断子 View 是否能接收到事件：<br>子元素是否在播放动画<br>点击事件的坐标是否落在子元素的区域内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">if (childWithAccessibilityFocus != null) &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line">if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure><br><br>- <code>mFirstTouchTarget</code>的赋值：对应代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line"><span class="keyword">break</span>;</div></pre></td></tr></table></figure><br><br>具体的赋值在<code>addTouchTarget</code>方法内部。<br>- 遍历所有子元素都没有被处理：这包含两种情况，第一种为 ViewGroup 没有子元素，第二种是子元素处理了点击事件，但 子元素的 <code>dispatchTouchEvent</code>方法返回了false（这一般是因为子元素在<code>onTouchEvent</code>方法中返回了false），此时 ViewGroup 将自己处理事件。<br>结论：<br><a id="result3"></a><br>&gt;结论 3<br>&gt;&gt;某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN 事件（onTouchEvent返回false），那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将重新交由它的父元素去处理，即父元素的 onTouchEvent 会被调用。意思就是事件一旦交给一个 View 来处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不再交给它来处理。<br><br><br> 这个结论可以结合代码来理解：<br><strong><code>某个 View 一旦开始处理事件</code></strong>：在开始循环前各个关键变量的值应该是这样的：<br>1.<code>mFirstTouchTarget</code>一定为空<br>2.<code>intercepted</code>一定为 false<br>3.可以推出<code>actionMasked == MOtionEvent.ACTION_DOWN</code>（这里参照 3.1 的部分）。<br><br> 之后遍历子 View 开始，在确定了<strong>某一个</strong>子 View <em>CV</em> 能接收到事件后，调用<em>CV</em>的<code>dispatchTouchEvent</code>方法（<code>dispatchTransformedTouchEvent</code>方法内部）：<br> - 若<code>dispatchTouchEvent</code>返回 true ，表示<em>CV</em>消耗了<strong>ACTION_DOWN</strong>事件，这时对<code>mFirstTouchTarget</code>赋值，使其指向<em>CV</em>，并跳出循环。当此次事件序列的下一个事件到达，假设为 ACTION_MOVE，此时<code>mFirstTouchTarget != null</code>成立，如果<em>CV</em>调用了<code>requestDisallowInterceptTouchEvent</code>方法启用<code>FLAG_DISALLOW_INTERCEPT</code>标记位（<code>disallowIntercept 为 true</code>），则 <code>intercepted</code>为 false，若<code>FLAG_DISALLOW_INTERCEPT</code>标记位没有被启用，那么 ViewGroup 的 <code>onInterceptTouchEvent</code>再次调用，参考 <a href="#rule">规则 1 </a>可以知道，一般情况下<code>intercepted</code>也会为 false，那么 <strong>同一事件序列中的其他事件都会交给它处理</strong>。<br> - 若<code>dispatchTouchEvent</code>返回 false，即 <em>CV</em> 不消耗 ACTION_DOWN 事件（onTouchEvent返回false）,此时会继续往下遍历子 View，如果遍历结束都没有被处理，那么 ViewGroup 将自己处理该事件，即<strong>父元素的 onTouchEvent 会被调用</strong>。<br><br>###### 3.2 View 的 dispatchTouchEvent 方法<br><br>View 的<code>dispatchTouchEvent</code>方法要简单一些，这里的 View 不包括 ViewGroup 。<br>&gt;View（不包括 ViewGroup）做为一个单独的元素，它没有子元素无法向下传递事件，所以只能自己处理事件。<br><br>（一） 事件传递到了某一个具体的 View 那就表明该 View 能接收到触摸事件，传递过来的第一个事件一定是此次事件序列的 <code>ACTION_DOWN</code> 事件，如果 View 消耗了 <code>ACTION_DOWN</code> 事件（返回true），那么该事件序列的后续事件都会传递给他，如果没消耗 <code>ACTION_DOWN</code> ，那么它将无法收到后续事件。参考  <a href="#result3">结论 3 </a><br><br>如果 View 只想处理 <code>ACTION_DOWN</code> 事件，而不处理其他事件，那可以覆写 <code>dispatchTouchEvent</code>方法或通过设置监听器实现（<code>setOnTouchListener(OnTouchListener l)</code>），在方法中加入如下判断即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="keyword">if</span>(event.getAction() == MotionEvent.ACTION_DOWN)</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">...</div></pre></td></tr></table></figure><br><br>（二） 内部监听和外部监听<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">-------------View#dispatchTouchEvent---------------</div><div class="line"> public boolean dispatchTouchEvent(MotionEvent event) &#123;</div><div class="line">...</div><div class="line">        if (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">            if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</div><div class="line">                result = true;</div><div class="line">            &#125;</div><div class="line">            //noinspection SimplifiableIfStatement</div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            if (li != null &amp;&amp; li.mOnTouchListener != null</div><div class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</div><div class="line">                result = true;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class="line">                result = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">...</div><div class="line">        return result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br><br>&gt;从源码可以看出，首先会判断有没有设置 OnTouchListener ，如果有，并且 OnTouchListener 中的 onTouch 方法返回 true，那么 onTouchEvent 就不会被调用，可见 OnTouchListener 的优先级高于 OnTouchEvent，这样做的好处是方便在外界处理触摸事件。<br><br>所以如果想屏蔽 View 默认的触摸事件处理只需为 View 设置监听器并返回 true 即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">view.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</div><div class="line">	  <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line"> &#125;);</div></pre></td></tr></table></figure><br><br>（三）View 的 onTouchEvent 对 DISEABLED 的处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">     <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class="line">         <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">             setPressed(<span class="keyword">false</span>);</div><div class="line">         &#125;</div><div class="line">         <span class="comment">// A disabled view that is clickable still consumes the touch</span></div><div class="line">         <span class="comment">// events, it just doesn't respond to them.</span></div><div class="line">         <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</div><div class="line">                 || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</div><div class="line">                 || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</div><div class="line">     &#125;</div><div class="line">...</div><div class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><br><br>&gt;从源码可看出，当 View 处于不可用状态时，只要 CLICKABLE ，LONG_CLICKABLE 和 CONTEXT_CLICKABLE  有一者为 true，onTouchEvent 就会返回 true，即消耗事件。<br><br>这里有个<code>CONTEXT_CLICKABLE</code>，这个常量指的又是什么呢？<br><code>CONTEXT_CLICKABLE</code>是 Android SDK 23 （Android 6.0）加入的，表示触控笔上下文单击（触控笔按钮）和鼠标右键单击是否可用。为其设置监听器时应使用 onContextClick 代替 onStylusButtonPress。<br><br>（四）View 的 onTouchEvent 对点击事件的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">      <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">             (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</div><div class="line">             (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</div><div class="line">       <span class="keyword">switch</span> (action) &#123;</div><div class="line">       <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">        ...</div><div class="line">                         <span class="keyword">if</span> (!focusTaken) &#123;</div><div class="line">                             <span class="comment">// Use a Runnable and post this rather than calling</span></div><div class="line">                             <span class="comment">// performClick directly. This lets other visual state</span></div><div class="line">                             <span class="comment">// of the view update before click actions start.</span></div><div class="line">                             <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</div><div class="line">                                 mPerformClick = <span class="keyword">new</span> PerformClick();</div><div class="line">                             &#125;</div><div class="line">                             <span class="keyword">if</span> (!post(mPerformClick)) &#123;</div><div class="line">                                 performClick();</div><div class="line">                             &#125;</div><div class="line">                         &#125;</div><div class="line">                     &#125;</div><div class="line">...</div><div class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><br><br>&gt;当 ACTION_UP 事件到达时，会触发 performClick 方法，如果 View 设置了 OnClickListener，那么 performClick 内部会调用它的 onClick 方法。<br><br>注释中说明了要使用 post 方法通过 Handler 执行 onClick，这让我们能够在 onClick 执行之前看到 View 的状态更新。<br><br>（五）CLICKABLE ，LONG_CLICKABLE 和 CONTEXT_CLICKABLE  的设置<br>&gt;View 的 LONG_CLICKABLE 属性默认为 false ，而 CLICKABLE 属性是否为 false 和具体的 View 相关，确切来说是可点击的 View 的 CLICKABLE 为 true ，不可点击的 View 的 CLICKABLE 为 false，比如 Button 是可点击的，而 TextView 是不可点击 的。通过 setClickable 、 setLongClickable 和 setContextClickable 可修改三者的值。另外，setOnClickListener、setOnLongClickListener 和 setOnContextClickListener 方法内部会自动将 View 的对应属性的 XXXable 值改为 true。<br><br>文章大部分摘抄自《Android 开发艺术探索》，第三章 3.4 节 —— View的事件分发机制，加上部分自己的理解，可能有错误，欢迎指正。<br><center><u><b><em>END</em></b></u></center>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/uploads/wechat.jpg" alt="James Duan WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/MotionEvent/" rel="tag"># MotionEvent</a>
          
            <a href="/tags/触摸事件分发/" rel="tag"># 触摸事件分发</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/05/04/Android-自定义View和属性动画ValueAnimator实现圆点指示器——支持“纵向视图”/" rel="next" title="Android：自定义View和属性动画ValueAnimator实现圆点指示器——支持“纵向视图”">
                <i class="fa fa-chevron-left"></i> Android：自定义View和属性动画ValueAnimator实现圆点指示器——支持“纵向视图”
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/13/Android-View-的工作原理/" rel="prev" title="Android：View 的工作原理">
                Android：View 的工作原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="James Duan" />
          <p class="site-author-name" itemprop="name">James Duan</p>
           
              <p class="site-description motion-element" itemprop="description">￥.￥</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/DuanJiaNing" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CAFE_BABE_Duan" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="2217611834" target="_blank" title="QQ">
                  
                    <i class="fa fa-fw fa-qq"></i>
                  
                  QQ
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/aimeimeits" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-blog"></i>
                  
                  CSDN
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="aimeimeits@gmail.com" target="_blank" title="email">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  email
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Android-View的事件分发机制"><span class="nav-number">1.</span> <span class="nav-text">Android-View的事件分发机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一-MotionEvent"><span class="nav-number">1.1.</span> <span class="nav-text">一. MotionEvent</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-1-常见的事件状态："><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 常见的事件状态：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-默认的规则"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 默认的规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二-触摸事件涉及到的主要方法"><span class="nav-number">1.3.</span> <span class="nav-text">二.  触摸事件涉及到的主要方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#三-事件分发过程"><span class="nav-number">1.4.</span> <span class="nav-text">三. 事件分发过程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#3-1-ViewGroup-的-dispatchTouchEvent-方法"><span class="nav-number">1.4.1.</span> <span class="nav-text">3.1 ViewGroup 的 dispatchTouchEvent 方法</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  Thu May 18 2017 08:00:00 GMT+0800 (中国标准时间) - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">James Duan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
